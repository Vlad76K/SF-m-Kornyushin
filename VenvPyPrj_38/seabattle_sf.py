# C2.5. Итоговое практическое задание
# Используя знания, полученные в данном модуле, напишите следующее приложение:
# Суть написанного приложения — игра «Морской бой».
# Интерфейс приложения должен представлять собой консольное окно с двумя полями 6х6 вида:
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | О | О | О | О | О | О |
# 2 | О | О | О | О | О | О |
# 3 | О | О | О | О | О | О |
# 4 | О | О | О | О | О | О |
# 5 | О | О | О | О | О | О |
# 6 | О | О | О | О | О | О |
#
# Игрок играет с компьютером. Компьютер делает ходы наугад, но не ходит по тем клеткам, в которые он уже сходил.
# Для представления корабля на игровой доске напишите класс Ship (в конструктор передаём информацию о его положении на доске).
# Опишите класс доски, на которую будут размещаться корабли.
# Корабли должны находится на расстоянии минимум одна клетка друг от друга.
# Корабли на доске должны отображаться следующим образом (пример):
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | ■ | ■ | ■ | О | О | О |
# 2 | О | О | О | О | ■ | ■ |
# 3 | О | О | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# На каждой доске (у ИИ и у игрока) должно находится следующее количество кораблей: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку.
# Запретите игроку стрелять в одну и ту же клетку несколько раз. При ошибках хода игрока должно возникать исключение.
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | X | X | X | О | О | О |
# 2 | О | О | О | О | X | X |
# 3 | О | T | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# В случае, если возникают непредвиденные ситуации, выбрасывать и обрабатывать исключения.
# Буквой X помечаются подбитые корабли, буквой T — промахи.
# Побеждает тот, кто быстрее всех разгромит корабли противника.
import sys

from numpy import random

class Dot: # класс точек на поле
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if (self.x, self.y) == (other.x, other.y):
            return True
        return False

class Ship:
    def __init__(self, length, start_point, vert_or_goriz, vitality):
        self.length = length
        self.start_point = start_point
        self.vert_or_goriz = vert_or_goriz
        self.vitality = vitality

    # возвращает список всех точек корабля
    def dots(self):
        ...

class Board:
    def __init__(self, list_prop_cell, list_ship_on_board, hid, num_live_ship):
        self.list_prop_cell = list_prop_cell          # Двумерный список, в котором хранятся состояния каждой из клеток
        self.list_ship_on_board = list_ship_on_board  # Список кораблей доски.
        self.hid = hid                                # Параметр hid типа bool — информация о том, нужно ли скрывать корабли на доске (для вывода доски врага) или нет (для своей доски).
        self.num_live_ship = num_live_ship            # Количество живых кораблей на доске
    def add_ship(self): # ставит корабль на доску (если ставить не получается, выбрасываем исключения)
        ...
    def contour(self): # обводит корабль по контуру
        # Он будет полезен и в ходе самой игры, и в при расстановке кораблей (помечает соседние точки, где корабля по правилам быть не может)
        ...
    def hid_board(self): # выводит доску в консоль в зависимости от параметра hid
        ...
    def out(self): # для точки (объекта класса Dot) возвращает True, если точка выходит за пределы поля, и False, если не выходит
        ...
    def shot(self): # делает выстрел по доске (если есть попытка выстрелить за пределы и в использованную точку, нужно выбрасывать исключения)
        ...

class Player:
    def __init__(self, self_board, other_board):
        self.self_board = self_board    # своя доска
        self.other_board = other_board  # доска противника
    def ask(self):  # метод, который «спрашивает» игрока, в какую клетку он делает выстрел. Пока мы делаем общий для AI
        ...         # и пользователя класс, этот метод мы описать не можем. Оставим этот метод пустым. Тем самым обозначим, что потомки должны реализовать этот метод

    def move(self):  # метод, который делает ход в игре
                     # Тут мы вызываем метод ask, делаем выстрел по вражеской доске (метод Board.shot), отлавливаем исключения,
                     # и если они есть, пытаемся повторить ход. Метод должен возвращать True, если этому игроку нужен повторный ход (например, если он выстрелом подбил корабль)
        ...

class AI(Player):
    def ask(self): # выбор случайной точки
        ...
class User(Player):
    def ask(self): # спрашивает координаты точки из консоли
        ...

class Game:
    def __init__(self, player_user, user_board, ai_user, ai_board):
        self.player_user = player_user
        self.user_board  = user_board
        self.ai_user = ai_user
        self.ai_boar = ai_board
    def random_board(self):  # метод генерирует случайную доску
        # мы просто пытаемся в случайные клетки изначально пустой доски расставлять корабли (в бесконечном цикле
        # пытаемся поставить корабль в случайную доску, пока наша попытка не окажется успешной). Лучше расставлять
        # сначала длинные корабли, а потом короткие. Если было сделано много (несколько тысяч) попыток установить
        # корабль, но это не получилось, значит доска неудачная и на неё корабль уже не добавить. В таком случае
        # нужно начать генерировать новую доску
        ...

    def greet(self):  # метод, который в консоли приветствует пользователя и рассказывает о формате ввода
        print(
            '*********************************************\n'
            '           Игра «Морской бой»\n'
            '*********************************************\n'
            'Вам дается два поля:\n'
            '   1. поле для расстановки своих кораблей\n'
            '   2. поле по которому Вы будете наносить\n'
            '      удары, пытаясь потопить корабли компьютера\n'
            'В обоих случаях аккуратно вводите координаты (строка - пробел - столбец). Например: 1 5\n'
            'При расстановке своих кораблей учитывайте, что нельзя их располагать вплотную дуг к другу\n'
            'При нанесении ударов по полю компьютера, нельзя бить в одну и ту же точку - это завершит игру\n'
            'Удачи!'
        )

    def loop(self):  # метод с самим игровым циклом. Здесь мы просто последовательно вызываем метод mode для игроков
                     # и делаем проверку, сколько живых кораблей осталось на досках, чтобы определить победу
        print('Поставьте корабли на поле: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку')
        print('Без диагональных и Г-образных')
        ...
    def start(self):  # запуск игры. Сначала вызываем greet, а потом loop
        self.greet()
        self.loop()

try:
    ...
except ValueError as error:
    print(error)
except IndexError as error:
    print(error)
else:
    print('Игра завершена!')
finally:
    print('Спасибо, что выбрали нашу компанию!')

