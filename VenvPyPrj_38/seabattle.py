# C2.5. Итоговое практическое задание
# Используя знания, полученные в данном модуле, напишите следующее приложение:
# Суть написанного приложения — игра «Морской бой».
# Интерфейс приложения должен представлять собой консольное окно с двумя полями 6х6 вида:
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | О | О | О | О | О | О |
# 2 | О | О | О | О | О | О |
# 3 | О | О | О | О | О | О |
# 4 | О | О | О | О | О | О |
# 5 | О | О | О | О | О | О |
# 6 | О | О | О | О | О | О |
#
# Игрок играет с компьютером. Компьютер делает ходы наугад, но не ходит по тем клеткам, в которые он уже сходил.
# Для представления корабля на игровой доске напишите класс Ship (в конструктор передаём информацию о его положении на доске).
# Опишите класс доски, на которую будут размещаться корабли.
# Корабли должны находится на расстоянии минимум одна клетка друг от друга.
# Корабли на доске должны отображаться следующим образом (пример):
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | ■ | ■ | ■ | О | О | О |
# 2 | О | О | О | О | ■ | ■ |
# 3 | О | О | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# На каждой доске (у ИИ и у игрока) должно находится следующее количество кораблей: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку.
# Запретите игроку стрелять в одну и ту же клетку несколько раз. При ошибках хода игрока должно возникать исключение.
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | X | X | X | О | О | О |
# 2 | О | О | О | О | X | X |
# 3 | О | T | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# В случае, если возникают непредвиденные ситуации, выбрасывать и обрабатывать исключения.
# Буквой X помечаются подбитые корабли, буквой T — промахи.
# Побеждает тот, кто быстрее всех разгромит корабли противника.
from numpy import random


class SeaBattle:
    _user = True
    _ship_list = []
    _pick_list = []
    def __init__(self, x, y, z, bf_list, pick_list, pick_list1):
        self.x = x
        self.y = y
        self.z = z
        self.bf_list = bf_list
        self.pick_list = pick_list
        self.pick_list1 = pick_list1

    def show(self): # вывод поля игры на экран
        print('  | 1 | 2 | 3 | 4 | 5 | 6 |           | 1 | 2 | 3 | 4 | 5 | 6 |')
        for i in range(6):
            print(i+1, '| {} | {} | {} | {} | {} | {} |'.format(*self.bf_list[i]), '       ', i+1, '| {} | {} | {} | {} | {} | {} |'.format(*self.pick_list[i]))
            i += 1
    @property
    def check_pick_error(self):
        ...
    def pick_ship(self): # здесь мы ищем в указанном месте корабль компьютера (визульно не отображается)
        if self.z:
            pl = self.pick_list1
        else:
            pl = self.bf_list
        if pl[self.x][self.y] == '■':
            return 'X'
        else:
            return 'T'
    @property
    def pick_cell_user(self): # ход игрока - выстрел по ячейке
        return 'X' #????????????????????????????????????????????????????
    @pick_cell_user.setter
    def pick_cell_user(self, value): # ход игрока - выстрел по ячейке
        if self.pick_list[self.x][self.y] == value:
            raise ValueError("По данной ячейке уже стреляли")
        else:
            self.pick_list[self.x][self.y] = value
    @property
    def pick_cell_comp(self): # ход игрока - выстрел по ячейке
        return 'X' #????????????????????????????????????????????????????
    @pick_cell_comp.setter
    def pick_cell_comp(self, value): # ход игрока - выстрел по ячейке
        if self.bf_list[self.x][self.y] == value:
            raise ValueError("По данной ячейке уже стреляли")
        else:
            self.bf_list[self.x][self.y] = value
    def check_win_comp(self): # проверки достижения победы
        for i in range(6):
            if '■' in self.bf_list[i]: # если находим "живой участок" у выставленных кораблей - нет победы у компа
                return True
        print('Компьютер выиграл!')
        return False
    def check_win_user(self):  # проверки достижения победы
        sum_el = 0
        for i in range(6):
            for j in range(6):  # len(self.pick_list[i])):
                if self.pick_list[i][j] == 'X':
                    sum_el += 1
        if sum_el == 11:  # все корабли компа подбиты =)
            print('Поздравляю! Вы победили!')
            return False
        return True
class Ship: # класс размещения кораблей на поле
    def __init__(self, x, y, bf_list):
        self.x = x
        self.y = y
        self.bf_list = bf_list
    def set_ship(self): # расставим корабли
        self.bf_list[self.x][self.y] = '■'

# user_data = [
#     ['О', 'О', 'О', 'О', 'О', 'О'],
#     ['О', 'О', 'О', 'О', 'О', 'О'],
#     ['О', 'О', 'О', 'О', 'О', 'О'],
#     ['О', 'О', 'О', 'О', 'О', 'О'],
#     ['О', 'О', 'О', 'О', 'О', 'О'],
#     ['О', 'О', 'О', 'О', 'О', 'О']
# ]
user_data = [
    ['■', '■', '■', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', '■', '■'],
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['■', 'О', '■', 'О', '■', 'О'],
    ['О', 'О', 'О', 'О', '■', 'О'],
    ['■', 'О', '■', 'О', 'О', 'О']
]
pick_visual = [
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', 'О', 'О'],
    ['О', 'О', 'О', 'О', 'О', 'О']
]
pick_hide = [
    ['■', 'О', '■', '■', 'О', 'О'],
    ['■', 'О', 'О', 'О', '■', 'О'],
    ['■', 'О', 'О', 'О', '■', 'О'],
    ['О', 'О', 'О', '■', 'О', 'О'],
    ['О', 'О', 'О', 'О', '■', 'О'],
    ['О', 'О', 'О', '■', 'О', '■']
]
try:
    sb_cls = SeaBattle(0, 0, True, user_data, pick_visual, pick_hide)
    sb_cls.show()

    s_cls = Ship(0, 0, user_data)

    # Распологаем корабли на поле
    print('Поставьте корабли на поле: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку')
    print('Без диагональных и Г-образных')
    # for i in range(11):
        # cell_coord_list = list(input('Введите координаты ячейки: ').split())
        # sb_cls.x = int(cell_coord_list[0])-1 # -1 из-за смещения индексов элемента массива по отношению к системе координат нашего поля
        # sb_cls.y = int(cell_coord_list[1])-1 # -1 из-за смещения индексов элемента массива по отношению к системе координат нашего поля
        # s_cls.x = int(cell_coord_list[0])-1 # -1 из-за смещения индексов элемента массива по отношению к системе координат нашего поля
        # s_cls.y = int(cell_coord_list[1])-1 # -1 из-за смещения индексов элемента массива по отношению к системе координат нашего поля
        # s_cls.set_ship()
    sb_cls.show() # М/б стоит отрисовывать поле после ввода кажой точки ? Возможно это будет нагляднее

    # начинаем батл =)
    print('Начнем сражение!')
    k = 0
    while sb_cls.check_win_user() and sb_cls.check_win_comp():
        sb_cls.z = k % 2 == 0
        if sb_cls.z: # определяем кто ходит (пользователю даем первый ход)
            print('Ход игрока!')
            cell_coord_list = list(input('Куда стреляем? Координаты: ').split())
        else:
            print('Ход компьютера!')
            cell_coord_list = [random.randint(1, 6), random.randint(1, 6)]
            print(cell_coord_list)
        sb_cls.x = int(cell_coord_list[0]) - 1  # -1 из-за смещения индексов элемента массива
                                                # по отношению к системе координат нашего поля
        sb_cls.y = int(cell_coord_list[1]) - 1  # -1 из-за смещения индексов элемента массива
                                                # по отношению к системе координат нашего поля
        if sb_cls.z: # определяем на каком поле играем
            sb_cls.pick_cell_user = sb_cls.pick_ship()
        else:
            sb_cls.pick_cell_comp = sb_cls.pick_ship()
        sb_cls.show()
        k += 1
except ValueError:
    # print('\nКод отлова')
    print()
else:
    print('\nКод, который выполнится если всё хорошо прошло в блоке try')
finally:
    print('\nКод, который выполнится по любому')

