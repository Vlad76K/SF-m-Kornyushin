# pi=3.14159
# print(pi**2/2)
# print(round(pi**2/2))
from selenium.webdriver import Keys

# pi = 31.4159265
# print ("%.4e" % (pi))

# s = "AsssDD"
# print(s.isdigit()) # строка состоит из цифр?
# print(s.isalpha()) # строка состоит из букв?
# print(s.isalnum()) # строка состоит из цифр и букв?

# colors = 'red green blue'
# colors_split = colors.split() # список цветов по-отдельности

# colors_joined = ' and '.join(colors_split) # объединение строк
# print(colors_joined)
# #red and green and blue

# numbers = '1 2 3 4 5 6 7'
# num_split = numbers.split()
# print("\n".join(num_split))

print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
# hours = 1
# minutes = 2
# seconds = 3
# print("%02d:%02d:%02d" % (hours, minutes, seconds))

# L = ["а", "б", "в", 0, 1, 2, 3, 4]
# print (L[ :4:-1 ])
# #[4, 3, 2]

# L = ['3.3', '4.4', '5.5', '6.6']
# print (list (map ( float , L)))

# string = input("Введите числа через пробел:")
# list_of_strings = string.split() # список строковых представлений чисел
# list_of_numbers = list(map(int, list_of_strings)) # cписок чисел
# print(sum(list_of_numbers[::3])) # sum() вычисляет сумму элементов списка

# list_input = input("Введите числа через пробел:").split() #получаем список
# #Подавал на вход: 1 12 3 55
# list_input[0], list_input[-1] = list_input[-1], list_input[0]
# list_input = list(map(int, list_input)) #преобразуем к целочисленному типу, чтобы посчитать сумму всех элементов
# list_input.append(sum(list_input)) #добавляем сумму всех всех элементов последним элементов списка
# #На выходе: [55, 12, 3, 1, 71]
# print(list_input)

# d = {'day' : 22, 'month' : 6, 'year' : 2015}
# print("||".join(d.keys()))

# book_title = input("Название книги: ") #получаем Название книги
# book_author = input("Автор книги: ") #получаем Название книги
# book_year = int(input("Год выпуска книги: ")) #получаем Название книги
# d = {'title':book_title, 'author':book_author, 'year':book_year}
# print(d)
# print(type(d['year']))

# #The Zen of PythonBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those!
# list_input = input("Введите текст:") #получаем список
# print("Количество уникальных символов: ", len(list(set(list_input))))
# #44

# a = {"Иванов", "Петров", "Васильев", "Антонов"}
# b = {"Петров", "Антонов", "Смирнов"}
# a_set, b_set = set(a), set(b) # используем множественное присваивание
# a_and_b = a_set.intersection(b_set)
# print('a_and_b', a_and_b)

# a = {1, 2, 3, 4, 5, 6, 7, 8}
# b = {2, 4, 6, 8, 10, 12}
# a_set, b_set = set(a), set(b) # используем множественное присваивание
# a_not_b = a_set.symmetric_difference(b_set)
# print('a_not_b', a_not_b)

# L = ['a', 'b', 'c']
# print(id(L))
# L.append('d')
# print(id(L))

# a = 5
# b = 3+2
# print(id(a))
# print(id(b))
# print(id(a)-id(b))

# import numpy as np
# np.random

# shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
# list_id_before = id(shopping_center[-1])
# # shopping_center[-1].append("Uniqlo")
# list_id_after = id(shopping_center[-1])
# print(list_id_before == list_id_after)

# Запишите вместо вопросительных знаков выражение, которое вернет True, если указывается високосный год, иначе False.
# Например, x = 2000 -> True; x = 1900 -> False; и т.д.
# Примечание: Если есть сомнения в том, какие именно годы високосные, обратитесь к Википедии
# def is_leap_year(x):
#     return ???
# x = int(input('Год: '))
# print((x % 400 == 0) or
#        not (x % 100 == 0) and
#       (x % 4 == 0))

# Дано n-значное целое число N. Определить: входят ли в него цифры 3 и 7
# N = 123456897
# print('3' in str(N) and '7' in str(N))

# Запишите вместо вопросительных знаков выражение, которое вернет True, когда каждое из чисел А и В нечетное
# def are_both_odd(A, B):
#     return ???
# A = 8
# B = 4
# if bool(A % 2 and B % 2):
#     print('А и В нечетные')
# else:
#     print('А и/или В четные')

# Использование вложенных операторов не всегда удобно. Вам дан код начинающего программиста, который не знает
# логические операторы. Он написал условие проверки принадлежности точки к координатной плоскости
# x = 1
# y = -1
# if x > 0 and y > 0:
#     print("Первая четверть")
# elif x < 0 and y > 0:
#     print("Вторая четверть")
# elif x < 0 and y < 0:
#     print("Третья четверть")
# elif x > 0 and y < 0:
#     print("Четвертая четверть")
# else:
#     print("Значение на оси координат")

# У вас есть заготовка функции — def get_wind_class(speed). Вам нужно вместо ??? написать код, который
# возвращает из функции класс ветра в зависимости от его характера:
# от 1 до 4 м/с включительно - "weak [1]"
# от 5-10 м/c - "moderate [2]"
# от 11-18 м/c - "strong [3]"
# от 19 м/c - "hurricane [4]"

# def get_wind_class(speed):
#     if 1 < speed <= 4:
#         return 'weak [1]'
#     elif 5 < speed < 10:
#         return 'moderate [2]'
#     elif 11 < speed < 18:
#         return 'strong [3]'
#     elif 19 < speed:
#         return 'hurricane [4]'
#     else:
#         return 'Неопределенный класс'
# print(get_wind_class(1))

# Вам дан словарь user_database с именами пользователей и их паролями. Допишите функцию check_user так, чтобы она
# по логину пользователя проверяла, существует он или нет, после чего с помощью вложенного условия проверяла
# правильность пароля этого пользователя.
# Функция должна возвращать только True или False.
# Примечание: чтобы вернуть True, напишите "return True"; чтобы вернуть False, напишите "return False"
# user_database = {
#     'user': 'password',
#     'iseedeadpeople': 'greedisgood',
#     'hesoyam': 'tgm'
# }
# def check_user(name, pwd):
#     if name in user_database and user_database[name] == pwd:
#         print(user_database[name] == pwd)
#         return True
#     else:
#         return False
#
# print(check_user('iseedeadpeople', 'tgm'))#'greedisgood'))
#!!!!!!!!!!!!!!!! Были ошибки - не правильно назвал переменные =)
# import warnings
# warnings.filterwarnings('ignore')
# # Введите свое решение ниже
# user_database = {
#     'user': 'password',
#     'iseedeadpeople': 'greedisgood',
#     'hesoyam': 'tgm'
# }
# def check_user(username, password):
#     print(username,' ',password)
#     if username in user_database and user_database[username] == password:
#         print(user_database[username] == password)
#         return True
#     else:
#         return False
# print(check_user(username='user', password='password'))

# Записать условие, которое является истинным, когда только одно из чисел А, В и С меньше 45.
# Иногда проще записать все условия и не пытаться упростить их
# A = 12
# B = 46
# C = 44
# if ((A > 45 and B <= 45 and C <= 45)or \
#     (A <= 45 and B > 45 and C <= 45) or \
#     (A <= 45 and B <= 45 and C > 45)):
#     print('Есть одно число большее 45')
# else:
#     print('Нет чила больше 45 или их несколько')

# Записать логические выражения, которые определяют, что число А не принадлежит интервалу от -10 до -1 или
# интервалу от 2 до 15
# A = -1
# if -10 <= A <= -1 or 2 <= A <= 15:
#     print("'A' принадлежит одному из диапазонов")
# else:
#     print("'A' не принадлежит одному из двух диапазонов")

# Дано двузначное число. Определить: входит ли в него цифра 5. Попробуйте решить её с использованием целочисленного
# деления и деления с остатком
# n = 15
# first_digit = n // 10
# second_digit = n % 10
#
# print((first_digit == 5) or (second_digit == 5))

# Проверить, все ли элементы в списке являются уникальными
# L = [1, 3, 1, 4, 5, 6]
# S = set(L)
# if len(L) != len(S):
#     print('Есть не уникальные элементы')
# else:
#     print('Все элементы уникальны')

# Дано натуральное восьмизначное число. Выясните, является ли оно палиндромом (читается одинаково
# слева направо и справа налево)
# N = 123454326
# N_str = str(N)
# print(N_str[::-1] == N_str)

# Соотнесите начало цикла с количеством повторений
# print(list(range(3, 5)))

# Попробуйте теперь самостоятельно подсчитать произведение всех чисел от 1 до N включительно
# P = 1  # заводим переменную-счётчик, в которой мы будем считать произведение
# N = 5
#
# # заводим цикл for, в котором мы будем проходить по всем числам от одного до N включительно
# for i in range(1, N + 1):  # равносильно выражению for i in [1, 2, 3, ... , N -1, N]:
#     print(P, " * ", i, " = ", (P * i))
#     P *= i  # умножаем на текущее значение i и перезаписываем значение P
# print("Конец цикла")
# print()
# print("Ответ: P = ", P)

# Написать программу, которая будет печатать лесенку следующего типа:
# n = 3
# *
# **
# ***
#
# n = 6
# for i in range(1, n + 1):
#     print('*'*i)

# Написать цикл, который будет складывать натуральные числа, пока их сумма не превысит 500.
# Заранее мы не знаем число шагов нашего цикла, но знаем условие, при котором нужно остановиться. Поэтому выберем
# цикл while и заведём две переменные для суммы и для текущего числа
# S = 0  # заводим переменную-счётчик, в которой мы будем считать сумму
# n = 1  # текущее натуральное число
# # заводим цикл while, который будет работать пока сумма не превысит 500
# while S < 500:  # делай пока ...
#     S += n  # увеличиваем сумму, равносильно S = S + n
#     n += 1  # так как сумма ещё не достигла нужного значения, то увеличиваем переменную-счётчик
#     print("Ещё считаю ...")
# print("Сумма равна: ", S)
# print("Количество чисел: ", n-1)

# Напишите цикл while, который находит максимальное натуральное число, квадрат которого меньше 1000
# i = 10
# while i**2 < 1000:
#     i += 1
# print(i-1,' ',(i-1)**2)

# Напишите бесконечный цикл while с условием выхода внутри цикла, находящего максимальное натуральное число,
# квадрат которого меньше 1000
# i = 1
# while True:
#     if i**2 > 1000:
#         break
#     i += 1
# print('i = ', i - 1)

# Дана двумерная матрица 3x3 (двумерный массив). Определить максимум и минимум каждой строки, а также их индексы
# random_matrix = [
#    [9, 2, 1],
#    [2, 5, 3],
#    [4, 8, 5]
# ]
#
# min_value_rows = []
# min_index_rows = []
# max_value_rows = []
# max_index_rows = []
#
# for row in random_matrix:
#     min_index = 0
#     min_value = row[min_index]
#     max_index = 0
#     max_value = row[max_index]
#
#     for index_col in range(len(row)):
#         if row[index_col] < min_value:
#             min_value = row[index_col]
#             min_index = index_col
#         if row[index_col] > max_value:
#             max_value = row[index_col]
#             max_index = index_col
#
#     min_value_rows.append(min_value)
#     min_index_rows.append(min_index)
#     max_value_rows.append(max_value)
#     max_index_rows.append(max_index)
#
# print("Минимальные элементы:", min_value_rows)
# print("Их индексы:", min_index_rows)
# print("Максимальные элементы:", max_value_rows)
# print("Их индексы:", max_index_rows)

# За один проход по циклу for мы можем либо получить само значение из списка, либо индекс, по которому дальше
# можем обратиться и получить элемент, как, например, здесь:
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# for i in range(len(list_)):  # равносильно выражению for i in [0, 1, 2, 3, 4, 5, 6]:
#     print("Индекс элемента: ", i)
#     print("Значение элемента: ", list_[i])  # с помощью индекса получаем значение элемента
#     print("---")
# print("Конец цикла")

# Но, чтобы убить двух зайцев сразу, есть функция enumerate. Она возвращает кортежи, где на первом месте стоит
# индекс элемента, а на втором — его значение.
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# # Функция enumerate возвращает данные в виде кортежей,
# # где на первом месте стоит индекс, а затем значение
# # [(0, -5), (1, 2), (2, 4), ...]
# for i, value in enumerate(list_):
#     print("Индекс элемента: ", i)
#     print("Значение элемента: ", value)  # с помощью индекса получаем значение элемента
#     print("---")
# print("Конец цикла")

# Начинающий программист написал программу, которая находит индекс последнего отрицательного элемента в списке.
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# # Объявим переменную, в которой будем хранить индекс отрицательного элемента
# index_negative = None
#
# for i in range(len(list_)):
#     if list_[i] < 0:
#         print("Отрицательное число: ", list_[i])
#         index_negative = i  # перезаписываем значение индекса
#         print("Новый индекс отрицательного числа: ", index_negative)
#     else:
#         print("Положительное число: ", list_[i])
#     print("---")
# print("Конец цикла")
# print()
# print("Ответ: индекс последнего отрицательного элемента = ", index_negative)
# Но он не знал, что есть функция enumerate. Ваша задача — подправить код так, чтобы он работал с помощью функции enumerate
# list_ = [-5, 2, 4, 8, 12, -7, 5]
# # Объявим переменную, в которой будем хранить индекс отрицательного элемента
# index_negative = None
# for i, value in enumerate(list_):
#     if value < 0:
#         print("Отрицательное число: ", value)
#         index_negative = i  # перезаписываем значение индекса
#         print("Новый индекс отрицательного числа: ", index_negative)
#      else:
#          print("Положительное число: ", value)
# print("Конец цикла")
# print()
# print("Ответ: индекс последнего отрицательного элемента = ", index_negative)

# # С помощью словаря в заданном тексте посчитать количество вхождений каждого символа.
# text = """
# У лукоморья дуб зелёный;
# Златая цепь на дубе том:
# И днём и ночью кот учёный
# Всё ходит по цепи кругом;
# Идёт направо -- песнь заводит,
# Налево -- сказку говорит.
# Там чудеса: там леший бродит,
# Русалка на ветвях сидит;
# Там на неведомых дорожках
# Следы невиданных зверей;
# Избушка там на курьих ножках
# Стоит без окон, без дверей;
# Там лес и дол видений полны;
# Там о заре прихлынут волны
# На брег песчаный и пустой,
# И тридцать витязей прекрасных
# Чредой из вод выходят ясных,
# И с ними дядька их морской;
# Там королевич мимоходом
# Пленяет грозного царя;
# Там в облаках перед народом
# Через леса, через моря
# Колдун несёт богатыря;
# В темнице там царевна тужит,
# А бурый волк ей верно служит;
# Там ступа с Бабою Ягой
# Идёт, бредёт сама собой,
# Там царь Кащей над златом чахнет;
# Там русский дух... там Русью пахнет!
# И там я был, и мёд я пил;
# У моря видел дуб зелёный;
# Под ним сидел, и кот учёный
# Свои мне сказки говорил.
# """
# text = text.lower()
# text = text.replace(" ", "")
# text = text.replace("\n", "")
# print(text)
# # Символы в верхнем и нижнем регистре будем считать одинаковыми, поэтому приведём текст в нижний регистр.
# # И удалим все пробелы и символы переноса строки.
# count = {}  # для подсчёта символов и их количества
# for char in text:
#    if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
#        count[char] += 1
#    else:
#        count[char] = 1
# # Заводим переменную-«счётчик» в виде словаря, где по ключу будет храниться символ, по значению — его количество.
# # Далее с помощью цикла for посимвольно будем проходиться по обработанному тексту и считать символы.
# for char, cnt in count.items():
#    print(f"Символ {char} встречается {cnt} раз")

# Допишите функцию check_h так, чтобы она проверяла гипотезу Сиракуз для числа n.
# Гипотеза Сиракуз заключается в том, что любое натуральное число можно свести к 1, если повторять над ним следующие действия:
# если число четное, то разделить его пополам,
# если нечетное - умножить на 3, прибавить 1 и результат разделить на 2.
# def check_h(n):
#     while n > 1:
#         if n % 2 != 0:
#             n = n * 3 +1
#         n = n // 2
#         if n == 1:
#             return True
#     return False
# print(check_h(2))

# Рассмотрим следующую задачу: в клетке находятся фазаны и кролики. Известно, что у них 35 голов и 94 ноги.
# Узнайте число фазанов и число кроликов.
# Количество фазанов и кроликов выражается целым числом, поэтому будем перебирать все возможные комбинации количества
# кроликов и фазанов, и если их суммарное количество ног равно указанному в условии, то мы нашли одно из решений.
# heads = 35  # количество голов
# legs = 94  # количество ног
# for r in range(heads + 1):  # количество кроликов
#     for ph in range(heads + 1):  # количество фазанов
#         #  если суммарное количество голов превышено или ног превышено, то переходим на следующий шаг цикла
#         if (r + ph) > heads or \
#             (r * 4 + ph * 2) > legs:
#             continue
#         if (r + ph) == heads and (r * 4 + ph * 2) == legs:
#             print("Количество кроликов", r)
#             print("Количество фазанов", ph)
#             print("---")

# Допишите функцию print_ladder так, чтобы она для числа n печатала лесенку следующего типа:
# n = 3
# *
# **
# ***
# n = 4
# *
# **
# ***
# ****
# Функция:
# def print_ladder(n):
#     i = 1
#     for i in range(1, n + 1):
#         print('*'*i)
# print_ladder(7)

# Посчитать среднюю температуру
# country_temperature = [
#     ['Тайланд', [75.2, 77, 78.8, 73.4, 68, 75.2, 77]],
#     ['Россия', [35.6, 37.4, 39.2, 41, 42.8, 39.2, 35.6]]
# ]
# temp = 0
# for country in country_temperature:
#     # print(len(country_temperature[i][1]))
#     temp = round(sum(map(float, country[1])) / len(country[1]), 2)
#     print(f'В стране {country[0]} средняя температура {temp} F')

# Вывести общий список ингридиентов (без разбивки на блюда), сложив в разрезе размерностей
# coock_book = {
#     'салат':[
#         {'ingredient_name':'сыр','quantity':50,'measury':'гр'},
#         {'ingredient_name': 'томаты', 'quantity': 2, 'measury': 'шт'},
#         {'ingredient_name': 'огурцы', 'quantity': 20, 'measury': 'гр'},
#         {'ingredient_name': 'маслины', 'quantity': 10, 'measury': 'гр'},
#         {'ingredient_name': 'оливковое масло', 'quantity': 20, 'measury': 'мл'},
#         {'ingredient_name': 'салат', 'quantity': 10, 'measury': 'гр'},
#         {'ingredient_name': 'перец', 'quantity': 20, 'measury': 'гр'}
#       ],
#     'пицца':[
#         {'ingredient_name':'сыр','quantity':20,'measury':'гр'},
#         {'ingredient_name': 'колбаса', 'quantity': 30, 'measury': 'гр'},
#         {'ingredient_name': 'бекон', 'quantity': 30, 'measury': 'гр'},
#         {'ingredient_name': 'оливки', 'quantity': 10, 'measury': 'гр'},
#         {'ingredient_name': 'томаты', 'quantity': 20, 'measury': 'гр'},
#         {'ingredient_name': 'тесто', 'quantity': 100, 'measury': 'гр'}
#       ],
#     'лимонад':[
#         {'ingredient_name':'лимон','quantity':1,'measury':'шт'},
#         {'ingredient_name': 'вода', 'quantity': 200, 'measury': 'мл'},
#         {'ingredient_name': 'сахар', 'quantity': 10, 'measury': 'гр'},
#         {'ingredient_name': 'лайм', 'quantity': 20, 'measury': 'гр'}
#     ]
# }
# new_dict = {}
# measury = {}
# i = 0
# item = 0
# for menu_ in coock_book.values():
#     for i in range(len(menu_)):
#         d = menu_[i]
#         key_new = d['ingredient_name'] + ' (' + d['measury'] + ')'
#         if (key_new in new_dict):
#             new_dict[key_new] = new_dict[key_new] + d['quantity']
#         else:
#             new_dict[key_new] = d['quantity']
#         i += 1
#     item += i
# print(new_dict)

# Рекурсия
# def check(n):
#     if (n < 2):
#         return (n % 2 == 0)
#     return check(n-2)
# n = int(input('Введите число '))
# if (check(n) == True):
#     print('четное число')
# else:
#     print('нечетное число')
#
# # Генераторы
# a = [i**2 for i in range(1, 6)]
# map(int, a)

# Генератор - итератор, элемены которого можно итерировать только один раз
# Итератор - подерживает функцию next() и помнит о том, какой эл.будет браться следующим
# итерируемый объект - объект позволяющий последовательно обойти/перебрать свои элементы

# s = [1, 2, 3]
# d = iter(s)
# print(next(d)) #1
# print(next(d)) #2
# print(next(d)) #3
# print(next(d)) #ошибка

# yield == return

# Декоратор
# def my_decor(func):
#     def wrapper():
#         print('start')
#         func()
#         print('end')
#     return wrapper()
# def my_func():
#     print('осн.функция')
#
# my = my_decor(my_func)
# my
# def my_decor(func):
#     def wrapper(n):
#         print('start')
#         func(n)
#         print('end')
#     return wrapper
# @my_decor
# def my_func(number):
#     print(number ** 2)
#
# my_func(10)

# Напишите функцию print_2_add_2, которая будет складывать 2 и 2 и печатать этот результат.
# Не забудьте вызвать функцию, чтобы увидеть результат
# def print_2_add_2():
#     print(2 + 2)
# print_2_add_2()

# Напишите функцию hello_world, которая будет печать приветственную строку «Hello World»
# def hello_world():
#     print('Hello World')
# hello_world()

# Напишите функцию, которая проверяет, является ли число n делителем числа a и выводит на экран
# соответствующее сообщение, является ли число делителем или нет
# def check_n(n, a):
#     if (a % n):
#         print('не является')
#     else:
#         print('является')
# check_n(3, 42)

# Напишите функцию, которая печатает «обратную лесенку» следующего типа
# n = 3
# ***
# **
# *
#
# n = 4
# ****
# ***
# **
# *
# def print_ladder(n):
#     i = 1
#     for i in range(1, n + 1):
#         print('*' * i)
# print_ladder(3)
# print()
# print_ladder(4)

# Напишите функцию, которая будет возвращать количество делителей числа а
# def devCount(a):
#     i = 0
#     for j in range(1, a + 1):
#         if not (a % j):
#             # print(j)
#             i += 1
#     return i
# print(devCount(5))

# Напишите функцию, которая проверяет, является ли данная строка палиндромом или нет, и возвращает результат проверки.
# Пример:
# check_palindrome("test")  # False
# check_palindrome("Кит на море не романтик")  # True
# def isPalindrom(inText):
#     inText = inText.lower()
#     inText = inText.replace(' ', '')
#
#     return (inText == inText[::-1])
#
# print(isPalindrom("Кит на море не романтик"))
# print(isPalindrom("test"))

# def get_mul_func(m):
#     nonlocal_m = m
#     def local_mul(n):
#         return n * nonlocal_m
#     return local_mul
# two_mul = get_mul_func(2)  # возвращаем функцию, которая будет умножать числа на 2
# print(two_mul)
# print(two_mul(5))  # 5 * 2

# Написать функцию, которая будет перемножать любое количество переданных ей аргументов
# def mult_func(*nums):
#     mul = 1
#     for n in nums:
#         mul *= n
#     return mul
# print(mult_func())
# print(mult_func(2))
# print(mult_func(2, 3, 6))
# print(mult_func(2, 3, 6, 8))

# Создадим неправильную функцию incorrect_func с указанием аргумента по умолчанию в виде списка. И вызовем эту
# функцию два раза
# def correct_func(name_arg=None):
#    if name_arg is None:
#        name_arg = []
#    print("Аргумент до изменения", name_arg)
#    name_arg.append(1)
#    print("Аргумент после изменения", name_arg)
#
# # вызовем два раза одну и ту же функцию
# correct_func()
# print('-----')
# correct_func()
# print('-----')
# correct_func([123])
# print('-----')
# correct_func(name_arg=[123])

# Давайте рассмотрим пример с вычислением чисел Фибоначчи.
# Если вкратце, то, как известно, последовательность Фибоначчи начинается с 1 и 1, после чего каждое новое число
# является результатом сложения двух предыдущих чисел. 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,...
# def rec_fibb(n):
#    if n == 1:
#        return 1
#    if n == 2:
#       return 1
#    return rec_fibb(n - 1) + rec_fibb(n - 2)
# rec_fibb(10)  # 55

# С помощью рекурсивной функции найдите сумму чисел от 1 до n
# def NumberSum(n):
#     if n == 1:
#         return 1
#     return n + NumberSum(n - 1)
# print(NumberSum(15))

# С помощью рекурсивной функции разверните строку
# def StrReverse(text):
#     if len(text) == 0:
#         return ''
#     else:
#         return text[-1] + StrReverse(text[:-1])
# print(StrReverse('test'))

# Дано натуральное число N. Вычислите сумму его цифр.
# При решении этой задачи нельзя использовать строки, списки, массивы (ну и циклы, разумеется)
# def NumberSum(n):
#     if n <= 0:
#        return 0
#     return n % 10 + NumberSum(n // 10)
# print(NumberSum(1876)) #22

# Создать функцию-генератор, возвращающую бесконечную последовательность натуральных чисел. По умолчанию она
# начинается с единицы, её шаг равен 1, но пользователь может указать любой шаг и любое число в качестве
# аргумента функции, с которого будет начинаться последовательность
# def count(start=1, step=1):
#     counter = start
#     # print(start, ' - ', step)
#     while True:
#         yield counter
#         counter += step
# start = int(input('Введите начальное значение: '))
# step = int(input('Введите шаг: '))
# for num in count(start, step):
#     if num > 100:
#         break
#     print('num = ', num)

# Создать генератор цикла, то есть в функцию на входе будет передаваться массив, например, [1, 2, 3], генератор
# будет вечно работать возвращая 1 2 3 1 2 3… и так далее
# def GenArray(array_):
#     while True:
#         for counter in array_:
#             yield counter
# i = 0
# for num in GenArray([1, 2, 3]):
#     if i > 100:
#         break
#     i += 1
#     print(num)
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# def repeat_list(list_):
#    list_values = list_.copy()
#    while True:
#        value = list_values.pop(0)
#        list_values.append(value)
#        yield value
#
# for i in repeat_list([1, 2, 3]):
#    print(i)

# Функция высшего порядка — в программировании это функция, принимающая в качестве аргументов другие функции
# или возвращающая другую функцию в качестве результата
# def twice_func(inside_func):
#     """Функция, выполняющая дважды функцию принятую в качестве аргумента"""
#     inside_func()
#     inside_func()
#
# def hello():
#     print("Hello")
#
# test = twice_func(hello)

# Замыкание в программировании — это функция, в теле которой присутствуют ссылки на переменные, объявленные вне
# тела этой функции в окружающем коде и не являющиеся её аргументами
# def make_adder(x):
#    def adder(n):
#        return x + n # захват переменной "x" из nonlocal области
#    return adder  # возвращение функции в качестве результата
# # функция, которая будет к любому числу прибавлять пятёрку
# add_5 = make_adder(5)
# print(add_5(10))  # 15
# print(add_5(100))  # 105

# Декораторы предназначены для подключения любого дополнительного поведения к основной функции,
# называемой декорируемой функцией, которое может выполняться до, после или даже вместо основной функции.
# При этом исходный код декорируемой функции никак не затрагивается
# - Декораторы добавляют дополнительное поведение функции без изменения её исходного кода.
# - Декораторы — вызовы дополнительных функций, поэтому они немного замедляют ваш код.
# - Для передачи аргументов декорируемой функции используйте *args и **kwargs.
# def my_decorator(a_function_to_decorate):
#     # Здесь мы определяем новую функцию - «обёртку». Она нам нужна, чтобы выполнять
#     # каждый раз при вызове оригинальной функции, а не только один раз
#     def wrapper():
#         # здесь поместим код, который будет выполняться до вызова, потом вызов
#         # оригинальной функции, потом код после вызова
#         print("Я буду выполнен до основного вызова!")
#         result = a_function_to_decorate()  # не забываем вернуть значение исходной функции
#         print("Я буду выполнен после основного вызова!")
#         return result
#     return wrapper
#
# def my_function():
#    print("Я - оборачиваемая функция!")
#    return 0
# print(my_function())
# # Я - оборачиваемая функция!
# # 0
# decorated_function = my_decorator(my_function)  # декорирование функции
# print(decorated_function())
# # Я буду выполнен до основного вызова!
# # Я - оборачиваемая функция!
# # Я буду выполнен после основного вызова!
# # 0

# Возьмите из предыдущего примера декорированные функции, которые возвращают время работы основной функции.
# Найдите среднее время выполнения для 100 выполнений каждой функции
# import time
# N = 100
# def decorator_time(fn):
#    def wrapper():
#        print(f"Запустилась функция {fn}")
#        t0 = time.time()
#        result = fn()
#        dt = time.time() - t0
#        print(f"Функция выполнилась. Время: {dt:.10f}")
#        return dt  # задекорированная функция будет возвращать время работы
#    return wrapper
#
# def pow_2():
#     return 1000000000 ** 2
#
# def in_build_pow():
#     return pow(1000000000, 2)
#
# mean_pow_2 = 0
# mean_in_build_pow = 0
# for _ in range(N):
#     mean_pow_2 += pow_2()
#     mean_in_build_pow += in_build_pow()
#
# print(f"Функция {pow_2} выполнялась {N} раз. Среднее время: {mean_pow_2 / N:.10f}")
# print(f"Функция {in_build_pow} выполнялась {N} раз. Среднее время: {mean_in_build_pow / N:.10f}")

# Синтаксический сахар в языке программирования — это синтаксические возможности, применение которых не влияет на
# поведение программы, но делает использование языка более удобным для человека
# def my_decorator(fn):
#    def wrapper():
#        fn()
#    return wrapper  # возвращается задекорированная функция, которая заменяет исходную
#
# # выведем незадекорированную функцию
# def my_function():
#    pass
# print(my_function)  # <function my_function at 0x7f938401ba60>
#
# # выведем задекорированную функцию
# @my_decorator
# def my_function():
#    pass
# print(my_function)  # <function my_decorator.<locals>.wrapper at 0x7f93837059d8>

# декоратор, в котором встроенная функция умеет принимать аргументы
# def do_it_twice(func):
#    def wrapper(*args, **kwargs):
#        func(*args, **kwargs)
#        func(*args, **kwargs)
#    return wrapper
#
# @do_it_twice
# def say_word(word):
#    print(word)
#
# say_word("Oo!!!")
# Oo!!!
# Oo!!!

# Напишите декоратор, который будет подсчитывать количество вызовов декорируемой функции. Для хранения
# переменной, содержащей количество вызовов, используйте nonlocal область декоратора
# def do_it_twice(func):
#     nonlocal_int = 0
#     def wrapper(*args, **kwargs):
#         nonlocal nonlocal_int
#         nonlocal_int += 1
#         func(*args, **kwargs)
#     return wrapper
#
# @do_it_twice
# def say_word(word):
#     print(word)
#
# say_word("Aa!!!")
# say_word("Uu!!!")
# say_word("Oo!!!")

# Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции в словаре. Словарь
# должен находиться в nonlocal области в следующем формате: по ключу располагается аргумент функции, по значению —
# результат работы функции, например, {n: f(n)}.
# И при повторном вызове функции декоратор будет брать значение из словаря, а не вычислять заново. То есть словарь
# можно считать промежуточной памятью на время работы программы, где будут храниться ранее вычисленные значения.
# Исходная функция, которую нужно задекорировать имеет следующий вид и выполняет простое умножение на число 123456789:
# def dict_write(func):
#     nonlocal_int = 0
#     nonlocal_dict = {}
#     def wrapper(nonlocal_int):
#         nonlocal nonlocal_dict
#         if nonlocal_int not in nonlocal_dict:
#             nonlocal_dict[nonlocal_int] = func(nonlocal_int)
#             print(nonlocal_dict)
#         else:
#             print('Возвращаемое значение: ', nonlocal_dict[nonlocal_int])
#     return wrapper
#
# @dict_write
# def f(n):
#    return n * 123456789
#
# for i in range(10):
#     f(i)
#     f(i)

# Как работают импорт и вызов функций
# def _print_hi(a):
#     return f'Hi, {a}'
# if __name__ == '__main__':
#     print(_print_hi('V'))

# Содержимое директории .git
# Рассмотрим, что содержится в папках и файлах:
#
# В файле config находятся настройки данного репозитория. Его содержимое представлено в текстовом формате.
# Файл HEAD указывает на текущую ветку.
# В файле index хранится содержимое индекса.
# В директории objects находится, собственно, база данных объектов Git. Если открыть каталог objects, то в нём будут находиться каталоги, имена которых представлены двумя шестнадцатеричными числами, внутри них будут файлы, имена которых представлены 38 шестнадцатеричными числами. Вместе имя каталога и файл образуют 40-разрядный хеш, взятый от имени файла и его содержимого.
# В директории refs находятся ссылки на объекты коммитов в этой базе (ветки).
# Директория logs хранит логи коммитов.
# В директории info расположен файл с глобальными настройкам игнорирования файлов. Он позволяет исключить файлы, которые вы не хотите помещать в .gitignore. Позднее мы остановимся на назначении файла .gitignore.
# В директории hooks располагаются клиентские и серверные триггеры. Желающие прочитать про них могут обратиться к руководству по Git.

# !!!!!!!!!!!!!!!!! Команды гита !!!!!!!!!!!!!!!!!!!
# git branch sf-kornyushin-dev1
# git checkout -b "sf-kornyushin-dev2"
# git add .
# git commit -m "говорящий коммент"
# git push   /    git push --set-upstream origin sf-kornyushin-dev1    - второй вариант подскажет сам Git


# python -m pip install selenium
# from selenium import webdriver
# from selenium.webdriver.common.by import By
#
# from time import sleep
#
# driver = webdriver.Chrome("/Users/пк/PythonProjects/SkillFactory/VenvPyPrj_38/chromedriver.exe")
# driver.get("https://google.com")
# driver.find_element(By.XPATH, "//*[@id='APjFqb']").send_keys('SkillFactory' + Keys.RETURN)
# sleep(2)
# driver.save_screenshot('sf.png')
# driver.quit()


# B5.1. Введение
# Итак, в этом юните мы:
# - повторим базовые понятия — переменные и типы данных;
# - глубже познакомимся с особенностями изменяемых и неизменяемых типов;
# - узнаем о новом типе данных — множестве (set) и закрепим работу с типами данных на практических задачах;
# - повторим логические операторы и углубим знания о принципах их работы;
# - закрепим знания об условных операторах на задачах;
# - узнаем о новых возможностях создания списков;
# - закрепим знания о циклах на практике и узнаем о работе с несколькими списками внутри цикла одновременно;
# - повторим создание функций различной сложности;
# - закрепим навыки работы с итераторами, генераторами и декораторами;
# - узнаем основы функционального программирования

# Встроенная функция id() позволяет получить число, которое называется идентичностью.Каждый объект при создании
# получает некоторое значение идентичности, и оно не может измениться у одного конкретного объекта во время
# выполнения программы.Также можно сказать, что это число ассоциируется с адресом области памяти компьютера, в
# которой хранится данный объект.
# Давайте проверим, так ли это.Скопируйте этот код и запустите его
# L = ['a', 'b', 'c']
# print(id(L))
#
# L.append('d')
# print(id(L))

# Задание 5.2.4
# С помощью функции id() можно увидеть часть механизма, обеспечивающего быстроту работы программ, написанных на Python.
# Предположим, что у нас есть две переменных:
# a = 5
# b = 3+2
# Каждая из них имеет значение равное 5, но создаются они совершенно разным образом. Первая — прямым присваиванием
# числа 5, вторая — как результат арифметической операции над другими числами-объектами.
# Какое значение идентичности будут иметь объекты данных, хранящиеся в этих переменных?
# print(id(a), ' - ', id(b), ' = ', id(a) - id(b))
# Удивительно, не правда ли? Дело в том, что некоторые целые числа и строки кешируются в памяти, позволяя не
# создавать каждый раз новый объект. Иными словами, Python при компиляции сам создаёт объекты некоторых видов
# и сохраняет их в памяти. И если в коде встречается «создание» такого объекта, то он подгружается из этой
# временной памяти (кеша)

# Задание 5.2.5
# Используя цикл while, найдите первое целое число, которое не кешируется в памяти
# a = 0
# b = 0
# while True:
#     a += 1
#     b += 1
#     n = id(a) - id(b)
#     if n != 0:
#         print(a, ' - ', b)
#         print(id(a), ' - ', id(b), ' = ', n)
#         break

# Задание 5.2.7
# Модифицируйте алгоритм из предыдущей задачи, чтобы найти первое отрицательное число, не хранящееся в кеше.
# Какое число получилось здесь?
# a = 0
# b = 0
# while True:
#     a -= 1
#     b -= 1
#     n = id(a) - id(b)
#     if n != 0:
#         print(a, ' - ', b)
#         print(id(a), ' - ', id(b), ' = ', n)
#         break

# Задание 5.2.8
# Впишите вместо знаков «?» операцию сравнения идентификаторов списков до и после обновления, чтобы программа
# распечатала True, если они равны, иначе — False
# shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
# list_id_before = id(shopping_center[-1])
# print(shopping_center[-1])
#
# shopping_center[-1].append("Uniqlo")
# list_id_after = id(shopping_center[-1])
# print(shopping_center[-1])
#
# print(list_id_before == list_id_after)

# Задание 5.2.9
# Напишите программу, которая на вход принимает текст и выводит количество уникальных символов
# textInput = input('Введите текст: ')
# print('Кол-во уникальных символов: ', len(set(list(textInput))))

# Задание 5.2.10
# Используя алгоритм из прошлой задачи, найдите количество уникальных символов в предложении
# textInput = '        The Zen of Python'
# # print(set(list(textInput)))
# print('Кол-во уникальных символов: ', len(set(list(textInput))))

# Задание 5.2.11
# Найдите ошибку в коде и запишите исправленную строку полностью в форму ответа. Представленная ниже программа
# должна находить множество символов, которые встречаются в двух строках одновременно
# a = input("Введите первую строку: ")
# b = input("Введите вторую строку: ")
# a_set, b_set = set(a), set(b) # используем множественное присваивание
# a_and_b = a_set.intersection(b_set)
# print(a_and_b)

# Задание 5.2.12
# Напишите программу, которая на вход получает две последовательности целых чисел, а возвращает список, в котором
# нет одинаковых элементов, встречающихся одновременно в обеих последовательностях.
# Какую операцию над множествами вы использовали?
# a = "1 2 3 5 4 6 7 8" #input("Введите первую последовательность целых чисел: ")
# b = "2 4 6 8 10 12" #input("Введите вторую последовательность целых чисел: ")
# a_set, b_set = set(list(a.split())), set(list(b.split())) # используем множественное присваивание
# a_and_b = a_set.symmetric_difference(b_set)
# res_list = list(map(int, a_and_b))
# res_list.sort()
# print(a_and_b)
# print(*res_list)#, sep = ', ')

# Задание 5.3.2
# Проверьте, что выведет пример кода, если переменная будет иметь значение
# some_var = (2,)
# if some_var is None:
#     print("NoneType")
# else:
#     print(type(some_var))

# Задание 5.3.3
# Какое значение будет у переменной b после запуска
# a = None # пустая строка
# b = a or 1
# print(b) #1

# Дело в том, что логические операторы возвращают не обязательно булевы значения (True или False), а значение
# одного из операндов. Это происходит согласно следующим правилам:
# 1. and: если все операнды являются истинными (ненулевые или непустые), то возвращается последнее истинное значение.
# print( 1 and "hello" and [False])
# # [False]
# Несмотря на то, что последний операнд похож на False, он является непустым списком, а значит, он истинный.
#
# 2. and: если один из операндов является ложным, то возвращается первый такой операнд.
# print(42 and 0 and '' and False)
# # 0
# Первый операнд является ненулевым числом — значит, истинный, а все остальные — ноль, пустая строка, булево
# значение False — ложные. И согласно правилу возвращается первый ложный операнд (слева направо).
#
# 3. or: если один из операндов является истинным, то возвращается первый такой операнд, а остальные игнорируются.
# print([] or 3.14 or False)
# # 3.14
# Первый операнд (пустой список) является ложным, следующий  (ненулевое число) — истинным, а значит, возвращается
# именно он, а все остальные игнорируются (не вычисляются).
#
# 4. or: если все операнды являются ложными, то возвращается последний.
# print(0 or '' or False)
# # False
# Поиск истинного операнда идёт также слева направо, но раз ни один такой не нашёлся, возвращается последнее
# значение, даже если оно ложное.

# Задание 5.3.5
# Что выведет программа?
# a = "foo"
# b = "bar"
# print(1 and a or b) #foo

# a = ""
# b = "bar"
# print(1 and a or b) #bar

# Задание 5.3.6
# Замените знаки «?» корректным выражением
# пусть a и b - переменные, которые мы хотим проверить
# a = 10
# b = 22
# if a and b : # проверка истинности обеих переменных
#     print("Обе переменные истинные")
#     print(a, b)

# Задание 5.3.7
# Замените знаки «?» корректным выражением
# пусть a и b - переменные, которые мы хотим проверить
# a = False
# b = True
# if a and b:
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print( a or b ) # печать значения одной переменной, которая является истинной

# Задание 5.3.8
# Программа должна выводить «Обе переменные ложные», если они являются таковыми. Дополните условный
# оператор последним блоком
# a = 0
# b = 0
# if a and b:
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print( a or b ) # печать значения одной переменной, которая является истинной
# else:
#     print('Обе переменные ложные')

# Задание 5.3.9
# Представим, что на вход нашей программы подаётся число. А мы хотим проверить, является ли оно целым, находится ли
# в определённом промежутке (например, от 100 до 999 включительно), да ещё и делится ли на 2 и 3 одновременно.
# Очень много условий. И такое случается в реальных проектах.
# Решение в лоб — использовать вложенные условные операторы. Один if внутри другого if и т.д. Наверняка есть способ
# сделать это быстрее и эффективнее, но для начала попробуем написать решение в таком варианте, чтобы было с чем сравнить:
# Напишите алгоритм, реализованный с помощью вложенных условных операторов, который проверяет заданные выше условия
# dict_ErrMess = {
#     0: 'Проверки успешно пройдены!',
#     1: 'Введено не целое число!',
#     2: 'Не делится на 2 или 3 без остатка!',
#     3: 'Введено не целое число!'
# }
# a = '130.3'#input('Введите число: ')
# def my_check_Input(inp):
#     if inp.find('.') > 0 or inp.find(',') > 0:
#         return 1 #'Введено не целое число!'
#     else:
#         inp = int(inp)
#     if (inp % 2 or inp % 3):
#         return 2 #'Не делится на 2 или 3 без остатка!'
#     if not (100 <= inp <= 999):
#         return 3 #'Не попали в диапазон от 100 до 999!'
#     return 0 #'Проверки успешно пройдены!'
#
# print(dict_ErrMess[my_check_Input(a)])

# Еще вариант аналогичной процедуры, но без понимания где и что отвалилось. При этом условие на соответствие int'у? в
# случае запроса значения "а" через input никогда не выполнится (нужно преобразовывать, а это при наличии точек,
# запятых и других "не чисел" не сработает - или надо искать как...)
# a = 120
# print(type(a) == int)
# if type(a) == int and 100 <= a <= 999 and a % 2 == 0 and a % 3 == 0:
#     print("Число удовлетворяет условиям")

#еще вариант - через all([])
# if all([type(a) == int,
#         100 <= a <= 999,
#         a % 2 == 0,
#         a % 3 == 0]):
#     print("Число удовлетворяет условиям")

# Задание 5.3.11
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True, если все числа
# ненулевые, и False, если хотя бы одно число равно 0
# a = "2 4 1 8 0 12 18"
# flg = True
# for i in list(map(int, a.split())):
#     if i == 0:
#         flg = False
#         break
# print(flg)

# правильный вариант
# # a = "2 4 1 8 0 12 18"
# flg = list(map(int, input().split()))
# print(all(flg))

# Задание 5.3.12
# Напишите программу, которая на вход принимает последовательность целых чисел и возвращает True, если все
# числа равны нулю, и False, если найдётся хотя бы одно ненулевое число. Разрешается использование только
# логических операторов и функций all([ ]) и any([ ]).
# # a = "0 0 0 0 0 0 0"
# # Ls = list(map(int, a.split()))
# Ls = list(map(int, input().split()))
# print(not any(Ls))

# Напишем генератор списков, в котором будут храниться квадраты первых 10 натуральных чисел.
# squares = [i**2 for i in range(1,11)]
# # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
# Можно модифицировать этот генератор списков таким образом, что в список будут включаться квадраты только от нечётных чисел.
# squares = [i**2 for i in range(1,11) if i % 2 == 1]
# # [1, 9, 25, 49, 81]

# Тип элемента, который будет включаться в список, может быть любым. Например, можно составить список из кортежей:
# list_tuples = [(i, i ** 2) for i in range(1, 11)]
# print(list_tuples)
# # [(1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81), (10, 100)]

# А используя вложенные генераторы списков, можно создать матрицу «одним махом»:
# M = [[i+j for j in range(5)] for i in range(5)]
# #[[0, 1, 2, 3, 4],
# # [1, 2, 3, 4, 5],
# # [2, 3, 4, 5, 6],
# # [3, 4, 5, 6, 7],
# # [4, 5, 6, 7, 8]]

# Задание 5.3.13
# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10
# M = [[i*j for j in range(1, 11)] for i in range(1, 11)]
# print(M)
#
#     [1,   2,  3,  4,  5,  6,  7,  8,  9,  10],
#     [2,   4,  6,  8, 10, 12, 14, 16, 18,  20],
#     [3,   6,  9, 12, 15, 18, 21, 24, 27,  30],
#     [4,   8, 12, 16, 20, 24, 28, 32, 36,  40],
#     [5,  10, 15, 20, 25, 30, 35, 40, 45,  50],
#     [6,  12, 18, 24, 30, 36, 42, 48, 54,  60],
#     [7,  14, 21, 28, 35, 42, 49, 56, 63,  70],
#     [8,  16, 24, 32, 40, 48, 56, 64, 72,  80],
#     [9,  18, 27, 36, 45, 54, 63, 72, 81,  90],
#     [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

# Задание 5.3.14
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент чётный,
# и False, если элемент нечётный
# L = [not(int(input()) % 2) for i in range(5)]
# print(L)

# Задание 5.3.15
# А вот здесь нам и поможет использование функций all([ ]) и any([ ]). Замените знаки «?» таким образом,
# чтобы программа выводила True, если есть хотя бы одно чётное число.
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(any(L))

# Задание 5.3.16
# Подумайте, как нужно записать логическое выражение, используя all([ ]) и any([ ]) над списком чётности,
# если его результат будет истинным тогда и только тогда, когда в списке есть хотя бы один чётный и
# хотя бы один нечётный элемент
# Ls = [3, 4, 1, 7]
# Ttl = [any(i % 2 == 0 for i in Ls) and any(i % 2 != 0 for i in Ls)]
# print(Ttl)
# В юните писали, что пример ниже работает. У меня он всегда дает False
# L = [3, 4, 1, 7]
# print(any(L) and not all(L))


# !!!!!!!!!!!!!!   zip()  !!!!!!!!!!!!!!
# Рассмотрим ещё одну полезную «фичу», которая упрощает работу со списками в циклах(а значит, и во вложенных
# генераторах).
# Допустим, у нас есть два списка одинакового размера:
# L = [i for i in range(10)]
# # 0 1 2 3 4 5 6 7 8 9
# M = [i for i in range(10,0,-1)]
# # 10 9 8 7 6 5 4 3 2 1
# Необходимо создать новый список, который будет состоять из произведений соответствующих элементов друг на друга
# В Python существует функция zip(), позволяющая объединить два списка в новый список кортежей,
# каждый из которых будет содержать по одному элементу из каждого списка.
# N = []
# for a, b in zip(L,M):
#     N.append(a*b)
#     print('a =', a, 'b =', b)
# print(N)

# Задание 5.3.17
# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M
# L = [i for i in range(10)]
# # 0 1 2 3 4 5 6 7 8 9
# M = [i for i in range(10,0,-1)]
# # 10 9 8 7 6 5 4 3 2 1
# N = [a * b for a, b in zip(L, M)]
# print(N)

# Задание 5.3.18
# Реализуйте программу, которая сжимает последовательность символов. На вход подаётся последовательность вида:
# inpTxt = "aaabbccccdaaa"
# ResTxt = ''
# j = 0
# count = 0
# for i in inpTxt:
#     if j < (len(inpTxt) - 1) and inpTxt[j] == inpTxt[j+1]:
#         count += 1
#     else:
#         ResTxt += inpTxt[j] + str(count + 1)
#         count = 0
#     j += 1
# print('ResTxt = ', ResTxt) # ResTxt = a3b2c4d1a3

# def linear_solve(a, b):
#     if a:
#         return b / a
#     elif not a and not b: # снова используем числа в логических выражениях
#         return "Бесконечное количество корней"
#     else:
#         return "Нет корней"
# print(linear_solve(5,2))

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня

# Задание 5.4.3
# Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения
# def D(a, b, c):
#     return b**2 - 4*a*c
# print(D(2, 3, 8))
#
# Задание 5.4.4
# Реализуйте функцию quadratic_solve(a, b, c), возвращающую «Нет вещественных корней» в случае отрицательного дискриминанта
# def quadratic_solve(a, b, c):
#     if D(a, b, c) < 0:
#         return 'Нет вещественных корней'
#     return D(a, b, c)
# print(quadratic_solve(1, 2, 1))

# Задание 5.4.5
# Модифицируйте функцию quadratic_solve(a, b, c), чтобы она возвращала единственный корень при условии нулевого дискриминанта
# def quadratic_solve(a, b, c):
#     Discr = D(a, b, c)
#     if Discr < 0:
#         return 'Нет вещественных корней'
#     elif Discr == 0:
#         return -b/(2*a)
#     else:
#         return (-b - Discr**0.5)/(2 * a), (-b + Discr**0.5)/(2 * a)
#     return Discr
# print(type(quadratic_solve(1, 12, 1)))

# Задание 5.4.9
# Напишите рекурсивную функцию, находящую минимальный элемент списка без использования циклов и встроенной функции min()
# def MinElRecursive(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < MinElRecursive(L[1:]) else MinElRecursive(L[1:])
# print(MinElRecursive([91, 0, -1]))

# Задание 5.4.10
# Напишите рекурсивную функцию, которая зеркально разворачивает число. Предполагается, что число не содержит нули
# def RecursiveReverse(L, Result):
#     strL = str(L)
#     Result += strL[-1]
#     return float(Result) if len(strL[0:len(strL)-1]) == 0 else RecursiveReverse(strL[0:len(strL)-1], Result)
#
# Result = ''
# D = 9101534
# Dnew = RecursiveReverse(str(D), Result)
# if str(D).find('.') > 0:
#     Dnew = float(Dnew)
# else:
#     Dnew = int(Dnew)
# print('Result = ', Dnew) # Result =  4351019

# def mirror(a, res=0):
#     return mirror(a // 10, res*10 + a % 10) if a else res
# print(mirror(91015.34))

# Задание 5.4.11
# Сейчас попробуем реализовать функцию equal(N, S), проверяющую, совпадает ли сумма цифр числа N с числом S.
# При написании программы следует обратить внимание на то, что, если S стала отрицательной,
# то необходимо сразу вернуть False

# def equal(N, S):
#     if N < 10:
#         return S == N
#     return False if (S - N % 10) < 0 else equal(N // 10, S - N % 10)
# print(equal(1564, 16))

# Задание 5.4.13
# Реализуйте функцию-генератор, каждое значение которого — приближение числа e с некоторым числом n
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
def e():
    n = 1
    while True:
        # print('n = ', n,' --- ',(1 + 1 / n) ** n)
        yield (1 + 1 / n) ** n
        n += 1

last = 0
for a in e(): # e() - генератор
    if (a - last) < 0.00000001: # ограничение на точность
        # print(a)
        break # после достижения которого завершаем цикл
    else:
        last = a # иначе - присваиваем новое значение
n = 51
e_n = (1 + 1/n)**n
# print("e_n = ", e_n)

# iter_obj = iter("Hello!")
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# print(next(iter_obj))
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# У нас есть функция, которая должна извлекать из базы данных какую-то информацию.
# На начальном этапе разработки мы не заботились о том, что это можно делать только при условии,
# что пользователь программы авторизовался, но сейчас время пришло. Попробуем написать декоратор,
# который позволяет вызвать функцию, только если она вызывается авторизованным пользователем
# yesno = input("""Введите Y, если хотите авторизоваться, или N,
#              если хотите продолжить работу как анонимный пользователь: """)
# auth = yesno == "Y"
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь не авторизован. Функция выполнена не будет")
#     return wrapper
# @is_auth
# def from_db():
#     print("some data from database")
# from_db()

# Задание 5.4.15
# Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя.
# Все username пользователей хранятся в глобальной области видимости в списке USERS. При согласии пользователя на
# авторизацию ему предлагается ввести username, который также хранится в глобальной области видимости. Функция
# должна использовать два декоратора: один для проверки авторизации вообще (реализован выше), второй — для
# проверки доступа
# USERS = ['admin', 'guest', 'director', 'root', 'superstar']
# def has_access(func1):
#     def wrapper():
#         username = input("Введите ваш username:")
#         print('username = ', username)
#         if username in USERS:
#             print('Доступ подтвержден!')
#             func1()
#         else:
#             print('Доступ запрещен!')
#     return wrapper
# yesno = input("""Введите Y, если хотите авторизоваться, или N,
#              если хотите продолжить работу как анонимный пользователь: """)
# auth = yesno == "Y"
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print('Пользователь авторизован')
#             func()
#         else:
#             print("Пользователь не авторизован. Функция выполнена не будет")
#     return wrapper
# @is_auth
# @has_access
# def from_db():
#     print("some data from database")
# from_db()

# Задание 5.5.1
# С помощью метода строки str.lower перевести все элементы списка в нижний регистр
# L = ['THIS', 'IS', 'LOWER', 'STRING']
# L = map(str.lower, L)
# print(list(L))

# Задание 5.5.2
# Отфильтровать из заданного списка только чётные элементы
# def chet(x):
#     return x != 0 and x % 2 == 0  # функция возвращает только True или False
# result = filter(chet, [-2, -1, 0, 1, -3, 2, -8])
# # Возвращается итератор, т.е. перечисляйте или приводите к списку
# print(list(result))   # [1, 2]

# Задание 5.5.3
# Предположим у нас есть список с данными о росте и весе людей. Задача — отсортировать их по индексу массы тела.
# Он вычисляется по формуле: свой рост в метрах возвести в квадрат, потом массу тела в килограммах
# разделить на полученную цифру
# (вес, рост)
# data = [
#    (82, 1.91),
#    (68, 1.74),
#    (90, 1.89),
#    (73, 1.79),
#    (76, 1.84)
# ]
# print(list(map(lambda i1, i2: i1 / i2**2, data))) #не работает (((
# print(sorted(data, key = lambda x: x[0] / x[1]**2)) #из ответа

# data1 = [82, 68, 90, 73, 76]
# print(list(map(lambda i: i / i**2, data1)))

# Задание 5.5.4
# Из списка в предыдущем задании найти кортеж с минимальным индексом массы тела
# data = [
#    (82, 1.91),
#    (68, 1.74),
#    (90, 1.89),
#    (73, 1.79),
#    (76, 1.84)
# ]
# print(min(data, key = lambda x: x[0] / x[1]**2)) # !!!

# Задание 5.5.5
# Замените знаки «?» корректным выражением. Вывести длину каждого элемента в списке
# Примечание. Попробуйте выполнить это задание без lambda-функций, используя только встроенные функции.
# a = ["asd", "bbd", "ddfa", "mcsa"]
# # print( ??? )
# print(list(map(len, a)))

# Задание 5.5.6
# Замените знаки «?» корректным выражением. Переведите все строки из списка в верхний регистр (заглавные буквы)
# Примечание. Попробуйте выполнить это задание без lambda-функций, используя только встроенные функции
# a = ["это", "маленький", "текст", "обидно"]
# # print( ??? )
# print(list(map(str.upper, a)))

# ИТОГОВОЕ ЗАДАНИЕ 5.6.1 (HW-02) !!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Реализовать игру «Крестики-нолики».
# Консоль, куда будет выводиться ход игры. Тут делать красиво мы умеем с помощью форматированных строк

# data = [
#    [0, 'A', 'B', 'C'],
#    [1, 'O', ' ', 'Q'],
#    [2, 'X', 'Y', 'Z']
# ]
# data = [
#    [0, ' ', ' ', ' '],
#    [1, ' ', ' ', ' '],
#    [2, ' ', ' ', ' ']
# ]
# def PrintTbl(d, flg=False):
#     if flg:
#         print('\n' * 20) # надо как-то избавляться от старых записей в консоли
#     print('   0  1  2')
#     print('{}  {}  {}  {}'.format(*d[0]))
#     print('{}  {}  {}  {}'.format(*d[1]))
#     print('{}  {}  {}  {}'.format(*d[2]))
#
# # Останавливаем игру, если все ячейки заполнены
# def StopGame(d):
#     for i in range(1, len(d)):
#         for j in range(3):
#             if d[i][j] == ' ':
#                 return False
#         # print(any(x for x in d[i]),' - ',d[i])
#         # print(all(x for x in d[i]), ' - ', d[i])
#     return True
#
# # Проверки на победу
# def checkWin(d):
#     # проверим строки на "три одинаковых в ряд"
#     for i in range(3):
#         if d[i][1] == ' ' or d[i][2] == ' ' or d[i][3] == ' ':  # пустые не смотрим
#             ...
#         else:
#             if d[i][1] == d[i][2] == d[i][3]:
#                 print(f'Строка {i} содержит одинаковые символы. Победа!')
#                 return True
#
#     # проверим столбцы на "три одинаковых в ряд"
#     for i in range(1, 4):
#         if d[0][i] == ' ' or d[1][i] == ' ' or d[2][i] == ' ':  # пустые не смотрим
#             ...
#         else:
#             if d[0][i] == d[1][i] == d[2][i]:
#                 print('Столбец 1 содержит одинаковые символы. Победа!')
#                 return True
#
#     # надо проверить диагонали
#     if d[0][1] != ' ' and (d[0][1] == d[1][2] == d[2][3]):
#         print('Диогональ содержит одинаковые символы. Победа!')
#         return True
#     if d[0][3] != ' ' and (d[0][3] == d[1][2] == d[2][1]):
#         print('Диогональ содержит одинаковые символы. Победа!')
#         return True
#
#     return False
#
# PrintTbl(data, True) # первоначальный вывод "сетки"
#
# EmptyCell = True
# step = 0
# while not checkWin(data):
#     if step > 10: break
#
#     inputStr = input('Введите пару чисел через пробел (строка столбец) и значение (X / O): ') #1 1 X
#
#     if inputStr == 'Q': break # для досрочного завершения игры
#
#     L = list(inputStr.split()) # обработка введенного с клавиатуры значения
#
#     if data[int(L[0])][int(L[1])+1] == ' ': # проверим не пытаются ли перезаписать значение
#         data[int(L[0])][int(L[1])+1] = L[2]
#     else:
#         EmptyCell = False
#         print('Данная клетка уже заполнена. Выберите другую')
#
#     if StopGame(data): # если все ячейки уже заполнены
#         break
#
#     if EmptyCell: # исключаем вывод в консоль для случая перезаписи данных
#         PrintTbl(data, True)
#
#     EmptyCell = True
#     step += 1 # счетчик делал для отладки


# ООП
# Парадигмы программирования
# В программировании выделяют несколько основных подходов, которые определяют стиль программирования — парадигмы
# программирования (набор идей и понятий)
# Рассмотрим две основных: императивную и декларативную

# Императивная парадигма программирования
# Эта парадигма основана на том, что разработчик (как и тестировщик) пишет для компьютера инструкции, которым тот следует
# К императивной парадигме относятся, например:
# процедурное;
# структурное;
# аспектно-ориентированное;
# объектно-ориентированное программирование
# **Canvas (холст) — это достаточно сложный объект библиотеки tkinter. Он помогает располагать геометрические фигуры,
#                    узоры, вставленные изображения и другие виджеты (например, метки, кнопки, текстовые поля)

# Декларативная парадигма программирования
# Эта парадигма отличается тем, что вы описываете проблему и ожидаемый результат, но не создаёте никаких инструкций:
# отсутствуют переменные, состояние и прочие понятия, которые свойственны императивной парадигме
# К декларативной парадигме относятся функциональное и логическое программирование
# SELECT num FROM N WHERE num > 3 AND num < 100;

# Принципы программирования
# YAGNI — You Ain’t Gonna Need It. (Суть принципа: реализуйте только поставленные задачи! Не делайте то, что не нужно)
# KISS —  Keep It Simple, Stupid. (Суть принципа: люди (включая пользователей продуктов и услуг), как правило, хотят
#         простых вещей, то есть простых в освоении и использовании. Избегайте чрезмерного проектирования и усложнения!)
# SOLID — Single responsibility principle/Open/closed principle/Liskov substitution principle/Interface segregation
#         principle/Dependency inversion principle. (Суть принципа: нужно избегать повторений одного и того же кода.
#         Лучше использовать универсальные свойства и функции)
# DRY — Don’t Repeat Yourself. (Суть принципа: нужно избегать повторений одного и того же кода. Лучше использовать
#       универсальные свойства и функции)

# SOLID (ещё один принцип)
# Single responsibility principle — принцип единственной обязанности (на каждый класс должна быть возложена одна
#                                   единственная обязанность). Это как при распределении задач внутри коллектива.
#                                   Эффективная работа строится тогда, когда каждый выполняет свою определённую задачу.
# Open/closed principle — принцип открытости/закрытости. Код, который вы пишете, должен быть масштабируемым, то есть
#                         должна быть возможность для его расширения. Но при этом внесение добавлений не должно
#                         требовать изменений в коде, который уже написан.
# Liskov substitution principle — принцип подстановки Барбары Лисков. Это принцип объектно-ориентированного
#                                 программирования, касающийся классов, интерфейсов, типов и подтипов. Суть его в том,
#                                 что каждый подтип должен дополнять, а не заменять базовый тип
# Interface segregation principle — принцип разделения интерфейса. Ни один клиент не должен зависеть от методов,
#                                   которые он не использует
# Dependency inversion principle — принцип инверсии зависимостей
# user_peter = {
#     "name": "Peter",
#     "email": "peterrobertson@mail.com",
#     "created_at": "2019-05-05",
#     "is_email_verified": True,
#     "purchases": ["Egg", "Spam", "Hat", "Knife", "Shield", "Book of Knight secrets"],
# }
# user_julia = {
#     "name": "Julia Donaldson",
#     "email": "juliadonaldson@mail.com",
#     "created_at": "2019-06-13",
#     "is_email_verified": True,
#     "purchases": ["Egg", "Spam", "Magic Brush"],
# }
# product_eggs = {
#     "name": "Egg",
#     "category": "food",
#     "is_available": False,
#     "quantity_in_stock": 0,
#     "vendor": "Dark Knight LTD",
#     "manager": "William The Conqueror",
# }
# def is_product_available(product):
#     return True if product["quantity_in_stock"] > 0 else False

# class Event:
#     def __init__(self, timestamp, event_type, session_id):
#         self.timestamp = timestamp
#         self.type = event_type
#         self.session_id = session_id
# events = [
#     {
#      "timestamp": 1554583508000,
#      "type": "itemViewEvent",
#      "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
#     {
#      "timestamp": 1555296337000,
#      "type": "itemViewEvent",
#      "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
#     {
#      "timestamp": 1549461608000,
#      "type": "itemBuyEvent",
#      "session_id": "@:NynteeXG:MYlskrqZbcmXNSFEJaZIsNVGeDLLpmct",
#     },
# ]
#
#
# for event in events:
#     event_obj = Event(timestamp=event.get("timestamp"),
# 	              event_type=event.get("type"),
# 		      session_id=event.get("session_id"))
#     print(event_obj.timestamp)

# Задание 1.8.1
# Создайте класс Cat в отдельном файле. Класс должен содержать конструктор с параметрами: имя, пол, возраст и методы get(), которые будут возвращать все параметры объекта.
# В другом файле создайте экземпляры класса. В качестве входных данных используйте данные о котах с сайта «Дом питомца». Не забудьте импортировать класс Cat в файл.
# Далее сделайте вывод информации о котах в консоль
# from cats import CatClass
# MyCatClass = CatClass('Барон', 'Мальчик', 2)
# MyCatClass1 = CatClass('Сэм', 'Мальчик', 2)
# print(MyCatClass.get_name(), ' --- ', MyCatClass.get_gender(), ' --- ', MyCatClass.get_age())
# print(MyCatClass1.get_name(), ' --- ', MyCatClass1.get_gender(), ' --- ', MyCatClass1.get_age())

# Задание 1.8.2
# Создайте класс Dog с помощью наследования класса Cat. Создайте метод get_pet() таким образом, чтобы он возвращал только имя и возраст.
# Далее сделайте вывод этой информации в консоль
# from pet import Dog
# MyDogClass = Dog('Мухтар', 0)
# print(MyDogClass.get_name(), ' --- ', MyDogClass.get_age())
#
# from cats import CatClass
# class Dog(CatClass):
#     def get_pet(self):
#         return f'{self.get_name()} {self.get_age()}'
# dog_1=Dog('Барбос', 'мальчик', 2)
# print(dog_1.get_pet())

# # Необходимо рассчитать площадь геометрической фигуры на основе полиморфизма:
# class Rectangle:
#     def __init__(self,a,b):
#         self.a = a
#         self.b = b
#     def get_area(self):
#         return self.a * self.b

# Задание 1.10.1
# Создайте класс одной из геометрических фигур (например, прямоугольника), где в конструкторе задаются атрибуты:
# начальные координаты x, y, width и height (или другие в зависимости от выбранной фигуры).
# Создайте метод, который возвращает атрибуты прямоугольника как строку (постарайтесь применить магический
# метод __str__). Для объекта прямоугольника со значениями атрибута x = 5, y = 10, width = 50, height = 100 метод
# должен вернуть строку Rectangle : 5, 10, 50, 100.
# class Rectangle:
#     def __init__(self, x, y, width, height):
#         self.x = x
#         self.y = y
#         self.width = width
#         self.height = height
#     def __str__(self):
#         return f'Params: {self.x}, {self.y}, {self.width}, {self.height}'
#
# p = Rectangle(5, 10, 50, 100)
# print(str(p))
# print(p)

# Задание 1.10.2
# В классе, написанном в предыдущем задании, создайте метод, который будет рассчитывать площадь фигуры.
# Выведите значение площади на экран
# class Rectangle:
#     def __init__(self, x, y, width, height):
#         self.x = x
#         self.y = y
#         self.width = width
#         self.height = height
#     def get_area_rectangle(self):
#         return self.height * self.width
#     def __str__(self):
#         return f'Params: {self.x}, {self.y}, {self.width}, {self.height}'
#
# p = Rectangle(5, 10, 50, 100)
# print(p)
# print(p.get_area_rectangle())

# Задание 1.10.3
# В проекте «Дом питомца» добавим новую услугу — электронный кошелек. Необходимо создать класс «Клиент», который
# будет содержать данные о клиентах и их финансовых операциях. О клиенте известна следующая информация: имя, фамилия, город, баланс.
# Далее сделайте вывод о клиентах в консоль в формате:
# «Иван Петров. Москва. Баланс: 50 руб.»
# class Clients:
#     def __init__(self, fname, lname, city, balance):
#         self.fname = fname
#         self.lname = lname
#         self.city = city
#         self.balance = balance
#
#     def get_client_info(self):
#         return f'«{self.fname} {self.lname}. {self.city}. Баланс: {self.balance} руб.»'
# cl = Clients('Иван', 'Петров', 'Москва', 50)
# print(cl.get_client_info())

# Задание 1.10.4
# Команда проекта «Дом питомца» планирует большой корпоратив для своих клиентов. Вам необходимо написать программу,
# которая позволит составить список гостей. В класс «Клиент» добавьте метод, который будет возвращать информацию
# только об имени, фамилии и городе клиента.
# Затем создайте список, в который будут добавлены все клиенты, и выведете его в консоль
# class Clients:
#     def __init__(self, fname, lname, city, balance):
#         self.fname = fname
#         self.lname = lname
#         self.city = city
#         self.balance = balance
#
#     def get_client_list(self):
#         return f'{self.fname}, {self.lname}, {self.city}'
#     def __str__(self):
#         return f'''"{self.fname} {self.lname}". {self.city}. Баланс: {self.balance} руб.'''
#
# cl1 = Clients('Иван', 'Петров', 'Москва', 50)
# cl2 = Clients('Петр', 'Иванов', 'Брянск', 30)
#
# cl_list = [cl1, cl2]
# # print(cl_list)
#
# for i in cl_list:
#     print(i.get_client_list())

# Задание 2.2.1
# Обсудите с коллегами по курсу в Slack в канале соответствующего модуля, нарушают ли статические методы ООП?
# Когда бы вы стали использовать статические методы?

# Задание 2.2.2
# Каким декоратором помечаются статические методы? (Ввод начинайте с «@»)

# Задание 2.2.4
# Напишите класс SquareFactory с одним статическим методом, принимающим единственный аргумент — сторону квадрата.
# Данный метод должен возвращать объект класса Square с переданной стороной
# class Square:
#     def __init__(self, side):
#         self.side = side
# class SquareFactory:
#     @staticmethod
#     def GET_SQUARE(side):
#         return Square(side)
#
# x = SquareFactory.GET_SQUARE(35)
# print(x.side)

# Инкапсуляция — это одна из основ объектно-ориентированного программирования, которая говорит нам о том, что поля
# (переменные) класса и его методы (функции класса) надо объединять в одну целую систему
# создадим класс собаки
# class Dog:
#     _happiness = 10
#
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age
#
#     @property
#     def human_age(self):
#         return self.age * 7.3
#
#     # добавим новое поле — шкала счастья
#     @property
#     def happiness(self):
#         return self._happiness
#
#     # с помощью декоратора setter мы можем неявно передать во второй
#     # аргумент значение, находящееся справа от равно, а не закидывать это
#     # значение в скобки, как мы это делали в модуле C1, когда не знали о
#     # декораторах класса
#     @happiness.setter
#     # допустим, мы хотим, чтобы счастье питомца измерялось шкалой от 0 до 100
#     def happiness(self, value):
#         if value <= 100 and value >= 0:
#             self._happiness = value
#         else:
#             raise ValueError("Happiness must be between 0 ... 100")
#
#
# jane = Dog("jane", 4)
# jane.happiness = 100  # осчастливим нашу собаку < :
# print(jane.human_age)
# print(jane.happiness)

# Вдобавок к комментариям в коде важно отметить, что декораторы .setter должны называться так же, как и метод,
# помеченный декоратором @property, для которого вы хотите устанавливать значение, иначе интерпретатор выдаст ошибку.
# Благодаря декоратору @.setter можно использовать инкапсуляцию, сохраняя привычное нам обращение к полю через точку,
# а установку нового значения через =. Вот такой вот магический декоратор @property.
# Ну и напоследок стоит сказать пару слов о декораторе @classmethod, который встречается довольно редко, ввиду его
# малой понятности для обывателей и синтаксической громоздкости.
# Используется он, как правило, чтобы открыть путь в полиморфизм (вспоминаем модуль C1, но если кратко — полиморфизм
# это разное поведение методов класса-родителя в классах-наследниках).
# Смотрим код:
# class ParentClass:
#     @classmethod
#     def method(cls, arg):
#         print("%s classmethod. %d" % (cls.__name__, arg))
#     @classmethod
#     def call_original_method(cls):
#         cls.method(5)
#     def call_class_method(self):
#         self.method(10)
#
# class ChildClass(ParentClass):
#     @classmethod
#     def call_original_method(cls):
#         cls.method(6)
# # Вызываем методы класса через класс.
# ParentClass.method(0)  # ParentClassclassmethod. 0
# ParentClass.call_original_method()  # ParentClassclassmethod. 5
#
# ChildClass.method(0)  # ChildClassclassmethod. 0
# ChildClass.call_original_method()  # ChildClassclassmethod. 6
#
# # Вызываем методы класса через объект.
# my_obj = ParentClass()
# my_obj.method(1)  # ParentClassclassmethod. 1
# my_obj.call_class_method()  # ParentClassclassmethod. 10

# Задание 2.3.4
# Создать вычисляемое свойство для класса Square. Сделайте метод по вычислению площади свойством. Сделайте сторону
# квадрата свойством, которое можно установить только через сеттер. В сеттере добавьте проверку условия, что сторона
# должна быть неотрицательной

# создадим класс собаки
# class Square:
#     def __init__(self, side1, side2):
#         self.side1 = side1
#         self.side2 = side2
#     # создадим свойство human_age, которое будет переводить возраст животного в человеческий
#     @property  # тот самый магический декоратор
#     def calc_square(self):
#         return self.side1 * self.side2
#
# side1 = 5
# side2 = 8
# calc_square = Square(side1, side2)
# # т.к. метод помечен декоратором property, то нам не надо вызывать этот метод, чтобы получить результат
# print(calc_square.calc_square)

# Задание 2.3.5
# Обсудите с коллегами в канале модуля, какие минусы могут быть при работе с методами, помеченными декораторами
# @property. Нарушают ли статические методы концепцию ООП?

# age = int(input("Сколько тебе лет?"))
# if age > 100 or age <= 0:
#     raise ValueError("Тебе не может быть столько лет")
# print(f"Тебе {age} лет!")  # Возраст выводится только если пользователь ввёл правильный возраст.

# Задание 2.4.8
# Создать скрипт, который будет в input() принимать строки, и их необходимо будет конвертировать в числа, добавить
# try-except на то, чтобы строки могли быть сконвертированы в числа.
# В случае удачного выполнения скрипта написать: «Вы ввели правильное число».
# В конце скрипта обязательно написать: «Выход из программы».
# Примечание: для отлова ошибок используйте try-except, а также блоки finally и else
# try:
#     inp_str = int(input('Введите строку: '))
#     print(inp_str)
# except ValueError:
#     print('Проблемы конвертации в int !')
# else:
#     print(f'Вы ввели {inp_str}')
# finally:
#     print('Выход из программы')


# C2.5. Итоговое практическое задание
# Используя знания, полученные в данном модуле, напишите следующее приложение:
# Суть написанного приложения — игра «Морской бой».
# Интерфейс приложения должен представлять собой консольное окно с двумя полями 6х6 вида:
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | О | О | О | О | О | О |
# 2 | О | О | О | О | О | О |
# 3 | О | О | О | О | О | О |
# 4 | О | О | О | О | О | О |
# 5 | О | О | О | О | О | О |
# 6 | О | О | О | О | О | О |
#
# Игрок играет с компьютером. Компьютер делает ходы наугад, но не ходит по тем клеткам, в которые он уже сходил.
# Для представления корабля на игровой доске напишите класс Ship (в конструктор передаём информацию о его положении на доске).
# Опишите класс доски, на которую будут размещаться корабли.
# Корабли должны находится на расстоянии минимум одна клетка друг от друга.
# Корабли на доске должны отображаться следующим образом (пример):
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | ■ | ■ | ■ | О | О | О |
# 2 | О | О | О | О | ■ | ■ |
# 3 | О | О | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# На каждой доске (у ИИ и у игрока) должно находится следующее количество кораблей: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку.
# Запретите игроку стрелять в одну и ту же клетку несколько раз. При ошибках хода игрока должно возникать исключение.
#   | 1 | 2 | 3 | 4 | 5 | 6 |
# 1 | X | X | X | О | О | О |
# 2 | О | О | О | О | X | X |
# 3 | О | T | О | О | О | О |
# 4 | ■ | О | ■ | О | ■ | О |
# 5 | О | О | О | О | ■ | О |
# 6 | ■ | О | ■ | О | О | О |
#
# В случае, если возникают непредвиденные ситуации, выбрасывать и обрабатывать исключения.
# Буквой X помечаются подбитые корабли, буквой T — промахи.
# Побеждает тот, кто быстрее всех разгромит корабли противника.

# см. решение в seabattle.py

# _comp_pick = {
#      1:[1, 1],  2:[1, 2],  3:[1, 3],  4:[1, 4],  5:[1, 5],  6:[1, 6],
#      7:[2, 1],  8:[2, 2],  9:[2, 3], 10:[2, 4], 11:[2, 5], 12:[2, 6],
#     13:[3, 1], 14:[3, 2], 15:[3, 3], 16:[3, 4], 17:[3, 5], 18:[3, 6],
#     19:[4, 1], 20:[4, 2], 21:[4, 3], 22:[4, 4], 23:[4, 5], 24:[4, 6],
#     25:[5, 1], 26:[5, 2], 27:[5, 3], 28:[5, 4], 29:[5, 5], 30:[5, 6],
#     31:[6, 1], 32:[6, 2], 33:[6, 3], 34:[6, 4], 35:[6, 5], 36:[6, 6]
# }
#
# # while i in range(6):
# print(list(_comp_pick.get(15)))
#
# class Area:
#     def __init__(self, side_x, side_y, radius):
#         self.side_x = side_x
#         self.side_y = side_y
#         self.radius = radius
#     def calc(self):
#         return self.side_x * self.side_y
#
# class Rectangle(Area):
#     def __init__(self, side_x, side_y):
#         self.side_x = side_x
#         self.side_y = side_y
#
#     def calc(self):
#         return self.side_x * self.side_y
#
# class Square(Area):
#     def __init__(self, side):
#         self.side = side
#
#     def calc(self):
#         return self.side * self.side
#
# class NonPositiveDigitException(ValueError):
#     def __init__(self, message, error):
#         super().__init__(message)  # вызов конструктора родительского класса
#         print(f'Errors: {error}')  # печатаем ошибку
#
# try:
#     square = Square(0)
#     square.side = int(input('Введите длину стороны: '))
#
#     if square.side <= 0 or square.side <= 0:
#         raise NonPositiveDigitException('message', 'Вы ввели сторону нулевой или отрицательной длины!')
#     else:
#         print(square.calc())
# except:
#     ...
# else:
#     print('Если код в try корректно завершился!')
# finally:
#     print('Спасибо, что выбрали нашу компанию! =)')

# import os
# help(os)
# print(os.getcwd())   # получить текущую директорию
# print(os.listdir())  # получить список файлов текущей директории


# Если вы планируете, что модуль будут запускать как самостоятельный скрипт – используйте следующую инструкцию:
# Здесь все вызовы функций и вывод информации на стандартный поток вывода
# if __name__ == '__main__':
#     pass

# import math
# print(math.trunc(math.fmod(math.fabs(-10000000), 55)+0.3))

# import time
#
# named_tuple = time.localtime()  # получить struct_time
# time_string1 = time.strftime("%H:%M:%S", named_tuple)  # только время
# time_string2 = time.strftime("%M", named_tuple)        # только минуты
# time_string3 = time.strftime("%d/%m/%Y", named_tuple)  # только дату
# time_string4 = time.strftime("%m", named_tuple)        # только месяц
#
# print(time_string1)  # только время
# print(time_string2)  # только минуты
# print(time_string3)  # только дату
# print(time_string4)  # только месяц

# import time
#
# i = 10
# while i != 0:
#     print(i)
#     time.sleep(1)
#     i -= 1
#     print('Время вышло!')

# Задание 3.3.7
# Вам нужно написать два модуля:
# 1. Первый должен содержать число Пи в виде константы 3.14, и две функции, которые будут считать площадь круга и прямоугольника.
# 2. Второй модуль должен импортировать первый, далее запрашивать у пользователя размеры круга и квадрата. В результате выводить, какая из фигур больше.
# from math_my import square_circle, square_rectangle
#
# side1 = int(input('Введите размер стороны 1: '))
# side2 = int(input('Введите размер стороны 2: '))
# print(square_rectangle(side1, side2))
#
# radius = int(input('Введите радиус круга: '))
# print(square_circle(radius))
#
# if square_circle(radius) > square_rectangle(side1, side2):
#     print('Площадь круга больше')
# else:
#     print('Площадь прямоугольника больше')

# Путь к файлу
# Путь (англ. path) — набор символов, показывающий расположение файла или каталога в файловой системе.
#
# В операционных системах UNIX разделительным знаком при записи пути является «/», в Windows — «\». Эти знаки служат
# для разделения названия каталогов, составляющих путь к файлу. Все вы видели, например, такой путь
# на ОС Windows: C:\Program Files. Это и есть путь до папки Program Files.
#
# Существует два типа пути:
# 1. абсолютный (путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущего
#    рабочего каталога или других обстоятельств. Его ещё называют полным),
# 2. относительный (это путь по отношению к текущему рабочему каталогу пользователя).
# import os
# start_path = os.getcwd()  # получить текущий путь
# print(start_path)            # C:\Users\пк\PythonProjects\SkillFactory\VenvPyPrj_38
# os.chdir("..")            # подняться на один уровень выше
# print(os.getcwd())           # C:\Users\пк\PythonProjects\SkillFactory
# os.chdir(start_path)      # вернёмся в ту директорию, из которой стартовали
# print(os.getcwd())           # C:\Users\пк\PythonProjects\SkillFactory\VenvPyPrj_38

# Задание 3.4.3
# Сделайте функцию, которая принимает от пользователя путь и выводит всю информацию о содержимом этой папки.
# Для реализации используйте функцию встроенного модуля os.walk(). Если путь не указан,
# то сравнение начинается с текущей директории
# import os
# def path_walk(top):
#     if not top:
#         top = os.getcwd()
#     for dirpath, dirnames, filenames in os.walk(top, topdown=True, onerror=None, followlinks=False):
#         print(dirpath)
#         print('Влож.каталоги:')
#         for dir_nm in dirnames:
#             print(dir_nm)
#         print('Файлы:')
#         for file_nm in filenames:
#             print(file_nm)
#         print(' ============================== ')
#
# start_path = input('Введите путь: ')
# path_walk(start_path)

# ответ из курса SF
# import os
# def walk_desc(path=None):
#     start_path = path if path is not None else os.getcwd()
#     for root, dirs, files in os.walk(start_path):
#         print("Текущая директория", root)
#         print("---")
#         if dirs:
#             print("Список папок", dirs)
#         else:
#             print("Папок нет")
#         print("---")
#         if files:
#             print("Список файлов", files)
#         else:
#             print("Файлов нет")
#         print("---")
#         if files and dirs:
#             print("Все пути:")
#         for f in files:
#             print("Файл ", os.path.join(root, f))
#         for d in dirs:
#             print("Папка ", os.path.join(root, d))
#         print("===")
# walk_desc()

# Примеры практического применения функции os.walk().
# В этом примере считается количество байтов, занятое файлами, не являющимися каталогами в каждом начальном
# каталоге, за исключением того, что не будем просматривать каталог CVS ни в одном подкаталоге:
# import os
# from os.path import join, getsize
#
# for root, dirs, files in os.walk('python/Lib/email'):
#     print(root, "consumes", end=" ")
#     print(sum(getsize(join(root, name)) for name in files), end=" ")
#     print("bytes in", len(files), "non-directory files")
#     if 'CVS' in dirs:
#         # не просматриваем каталог `CVS`
#         dirs.remove('CVS')
# В следующем примере простая реализация функции shutil.rmtree(). В функции os.walk() указан обход
# дерева каталогов снизу вверх, это очень важно, т. к. функция os.rmdir() не позволяет удалить каталог, пока он не пуст:
# ВНИМАНИЕ! В примере удаляется все из каталога, указанного в переменной top, при условии, что нет символических ссылок.
# Это опасно! Например, если top == '/', это может удалить все файлы на диске.
# import os
# for root, dirs, files in os.walk(top, topdown=False):
#     for name in files:
#         os.remove(os.path.join(root, name))
#     for name in dirs:
#         os.rmdir(os.path.join(root, name))

# Работа с файлами
# Смотрим: C:\Users\пк\PythonProjects\SkillFactory\1111.txt
# f = open('..\\1111.txt', 'a', encoding='utf8')
# f.write('Новая строка\n')
# f.close()
# f = open('..\\1111.txt', 'r', encoding='utf8')
# print(f.read(10))
# print(f.read(10))
# f.close()

# Чтение и запись построчно
# writelines — записывает список строк в файл;
# readline — считывает из файла одну строку и возвращает её;
# readlines — считывает из файла все строки в список и возвращает их
# f = open('..\\1111.txt', 'a', encoding='utf8')  # открываем файл на дозапись
# sequence = ["other string\n", "123\n", "test test\n"]
# f.writelines(sequence)  # берёт строки из sequence и записывает в файл (без переносов)
# f.close()
# f = open('..\\1111.txt', 'r', encoding='utf8')
# print(f.readlines())  # считывает все строки в список и возвращает список
# f.close()
# f = open('..\\1111.txt', 'r', encoding='utf8')
# print(f.readline())  # This is a test string
# print(f.read(4))  # This
# print(f.readline())  # is a new string
# f.close()
#
# # Файл как итератор
# f = open('..\\1111.txt', 'r', encoding='utf8')
# for line in f:
#     print(line.strip())
# f.close()
#
# with open('..\\1111.txt', 'r', encoding='utf8') as f:  # автоматическое закрытие файла
#     a = f.read(10)
#     b = f.read(30)
# print(a)
# print(b)

# Задание 3.4.4
# Создайте любой файл на операционной системе под название input.txt и построчно перепишите его в файл output.txt
# r — открыть на чтение (по умолчанию);
# w — перезаписать и открыть на запись (если файла нет, то он создастся);
# x — создать и открыть на запись (если уже есть — исключение);
# a — открыть на дозапись (указатель будет поставлен в конец);
# t — открыть в текстовом виде (по умолчанию);
# b — открыть в бинарном виде.
# f_in = open('..\\input.txt', 'r', encoding='utf8')
# f_out = open('..\\output.txt', 'x', encoding='utf8')
# for line in f_in:
#     f_out.write(line)
# f_in.close()
# f_out.close()
#
# with open('input.txt', 'r') as input_file:
#    with open('output.txt', 'w') as output_file:
#        for line in input_file:
#            output_file.write(line)

# Задание 3.4.5
# Дан файл numbers.txt, компоненты которого являются действительными числами (файл создайте самостоятельно и заполните
# любыми числами, в одной строке одно число). Найдите сумму наибольшего и наименьшего из значений и
# запишите результат в файл output.txt
# with open('..\\numbers.txt', 'r') as input_file:
#    with open('..\\output.txt', 'w') as output_file:
#        min_num = max_num = float(input_file.readline())  # считали первое число
#        for line in input_file:
#            if float(line) < min_num:
#                min_num = float(line)
#            if float(line) > max_num:
#                max_num = float(line)
#        sum_out = min_num + max_num
#        output_file.write(str(sum_out))
#        output_file.write('\n')
#        output_file.write(str(min_num))
#        output_file.write('\n')
#        output_file.write(str(max_num))
#        output_file.write('\n')

# Задание 3.4.6
# В текстовый файл построчно записаны фамилии и имена учащихся класса и их оценки за контрольную.
# Выведите на экран всех учащихся, чья оценка меньше 3 баллов. Cодержание файла:
# Иванов О. 4
# Петров И. 3
# Дмитриев Н. 2
# Смирнова О. 4
# Керченских В. 5
# Котов Д. 2
# Бирюкова Н. 1
# Данилов П. 3
# Аранских В. 5
# Лемонов Ю. 2
# Олегова К. 4
# with open('..\\input.txt', 'r', encoding='utf8') as input_file:
#     for line in input_file:
#         line_lst = line.strip().split('.')
#         if int(line_lst[1]) < 3:
#             # print(line.strip())
#             print(*line.strip().split()[:-1])
#
# with open('..\\input.txt', encoding="utf8") as file:
#     for line in file:
#         points = int(line.split()[-1])
#         if points < 3:
#             name = " ".join(line.split()[:-1])
#             print(name)

# Задание 3.4.7
# Выполните реверсирование строк файла (перестановка строк файла в обратном порядке)
# with open('..\\input.txt', 'r', encoding='utf8') as f:
# 	f.seek(0, 2)
# 	fsize = f.tell()
# 	f.seek(max(fsize - 1024, 0), 0)
# 	lines = f.readlines()
#
# start = 0
# for x in lines[::-1]:
# 	if x.startswith('\n'):
# 		start = lines.index(x)
# 		break
# print(lines[start + 1:])

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# with open('input.txt', 'r') as input_file:
#     with open('output.txt', 'w') as output_file:
#         for line in reversed(input_file.readlines()):
#             output_file.write(line)
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# import io, os
# class ReverseFile(io.IOBase):
#     def __init__ (self, filename, headers=1):
#         self.fp = open(filename, 'r', encoding='utf8')
#         self.headers = headers
#         self.reverse = self.reversed_lines()
#         self.end_position = -1
#         self.current_position = -1
#
#     def readline(self, size=-1):
#         if self.headers > 0:
#             self.headers -= 1
#             raw = self.fp.readline(size)
#             self.end_position = self.fp.tell()
#             return raw
#
#         raw = next(self.reverse)
#         if self.current_position > self.end_position:
#             return raw
#
#         raise StopIteration
#
#     def reversed_lines(self):
#         # Generate the lines of file in reverse order.
#         part = ''
#         for block in self.reversed_blocks():
#             block = block + part
#             block = block.split('\n')
#             block.reverse()
#             part = block.pop()
#             if block[0] == '':
#                 block.pop(0)
#
#             for line in block:
#                 yield line + '\n'
#
#         if part:
#             yield part
#
#     def reversed_blocks(self, blocksize=0xFFFF):
#         # "Generate blocks of file's contents in reverse order."
#         file = self.fp
#         file.seek(0, os.SEEK_END)
#         here = file.tell()
#         while 0 < here:
#             delta = min(blocksize, here)
#             here -= delta
#             file.seek(here, os.SEEK_SET)
#             self.current_position = file.tell()
#             yield file.read(delta)
#
# rev = ReverseFile("..\\input.txt")
# print(rev.reversed_lines)
# for line in rev.reversed_lines():
#     print(f'{line.strip()}')

# Контекстный менеджер — определенная структура в языке Python (класс или генератор), основывающаяся на главном
# принципе: при его открытии и закрытии срабатывает заранее написанный программистом код
# with open("file.bin", "wt") as f: # открываем файл с помощью with
#     f.write("abcdefg")
# Чтобы написать контекстный менеджер нужно всего лишь помнить о нескольких вещах:
# - Нужно создать класс и написать в нём метод __enter__. Код в этом методе будет выполняться при входе в контекстный
#   менеджер (при создании объекта с ключевым словом with).
# - Написать метод __exit__. Этот метод будет выполнять код, помещённый в него, на выходе.
# - Добавить в этот метод три дополнительных аргумента помимо self — exc_type, exc_val, exc_tb.
# exc_type — это тип исключения, из-за которого вылетел контекстный менеджер. Если всё прошло успешно, то значение этого аргумента будет None.
# exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, этот аргумент будет None.
# exc_tb — объект сообщения от интерпретатора. Лучше его вообще не трогать, если вы не разработчик языка, но, тем не менее, он всегда ждёт вас здесь. Возможно, когда-то, после нашего курса вы…
# Пример контекстного менеджера:
# from datetime import datetime
# import time  # проверять действие измерителя будем с помощью библиотеки time
# # вся суть этого измерителя заключается в том, что мы считаем разницу в секундах между открытием и
#   закрытием контекстного менеджера
# class Timer:
#     def __init__(self):
#         pass
#     def __enter__(self):  # этот метод вызывается при запуске с помощью with. Если вы хотите вернуть какой-то объект,
#                           # чтобы потом работать с ним в контекстном менеджере, как в примере с файлом, то просто
#                           # верните этот объект через return
#         self.start = datetime.utcnow()
#         return None
#     def __exit__(self, exc_type, exc_val, exc_tb):  # этот метод срабатывает при выходе из контекстного менеджера
#         print(f"Time passed: {(datetime.utcnow() - self.start).total_seconds()}")
# with Timer():
#     time.sleep(2)  # засыпаем на 2 секунды
# В консоль должно вывестись примерно следующее: Time passed: 2.00099

# Вариант того же КМ через генератор:
# from datetime import datetime
# import time
# from contextlib import contextmanager  # импортируем нужный нам декоратор
#
# @contextmanager  # оборачиваем функцию в декоратор contextmanager
# def timer():
#     start = datetime.utcnow()
#     yield  # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
#     print(f"Time passed: {(datetime.utcnow() - start).total_seconds()}")
#
#
# with timer():
#     time.sleep(2)

# Задание 3.5.6
# Напишите контекстный менеджер, который умеет безопасно работать с файлами.
# В конструктор объекта контекстного менеджера передаются два аргумента: первый — путь к файлу, который надо открыть,
# второй — тип открываемого файла (для записи, для чтения и т. д.).
# При входе в контекстный менеджер должен открываться файл, и возвращаться объект для работы с этим файлом.
# При выходе из контекстного менеджера файл должен закрываться. (Эталоном работы можно считать контекстный менеджер open)
# from contextlib import contextmanager  # импортируем нужный нам декоратор
# @contextmanager  # оборачиваем функцию в декоратор contextmanager
# def file_reader(file_name, open_type):
#     obj = open(file_name, open_type, encoding='utf8')
#     yield obj # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
#     obj.close()
#     print("Работа завершена!")
#
# with file_reader('..\\input.txt', 'r') as obj_with:
#     for line in obj_with:
#         print(line.strip())

# или через класс:
# class FileReader:
#     def __init__(self, file_name, open_type):
#         self.file_name = file_name
#         self.open_type = open_type
#         self.obj = open(self.file_name, self.open_type, encoding='utf8')
#
#     def __enter__(self):
#         return self.obj
#
#     def __exit__(self, exc_type, exc_val, exc_tb):
#         self.obj.close()
#
# with FileReader('..\\input.txt', 'r') as obj_with:
#     for line in obj_with:
#         print(line.strip())
#
# Задание 3.5.7
# Обсудите с коллегами в канале модуля в Slack преимущества использования контекстного менеджера. С какими
# концепциями программирования он хорошо сочетается?

# По аналогии критериями эффективности или, иначе, сложности алгоритмов являются временной и пространственный.
# Временная сложность алгоритма говорит нам о том, какое количество времени может потребоваться для выполнения этого
# алгоритма. И, естественно, она зависит от размера входных данных — точно так же,  как уборка от площади квартиры.
# Пространственная сложность алгоритма связана с количеством памяти, которое он использует в ходе своей работы. Здесь
# работает та же аналогия с приготовлением ужина — зависимость от количества посуды, которая загрязняется из-за
# готовки. Здесь и далее в основном будем говорить о временной сложности алгоритмов и в некоторых случаях затрагивать
# пространственную, когда это будет необходимо.
#
# Самый простой, самый эффективный алгоритм, к которому все стремятся, — это константный алгоритм
# Константным, или постоянным по времени, называется алгоритм, который выполняет необходимое действие всегда за
# одинаковое количество времени (с точностью до небольшого множителя, вызванного техническими характеристиками
# вычислительной машины)
# К таким «алгоритмам» относят очень простые операции:
# - присваивание,
# - арифметические операции,
# - логические операции,
# - сравнение объектов,
# - некоторые другие действия, которые мы рассмотрим в ходе изучения модуля.
#
# Линейные и логарифмические алгоритмы

# Массивы, для которых заранее резервируется фиксированная область памяти, называют статическими.
# В отличие от них существуют динамические массивы, которые с помощью буферного механизма, могут изменять свой размер
# Важно различать:
# - логический размер массива (logical size) — фактическая заполненность массива;
# - зарезервированный размер памяти (capacity) — вместимость памяти для этого массива

# Пример 1
# Вспомним нашу аналогию с ужином. Ужин закончился, тарелки постепенно перемещаются в раковину — одна на другую.
# Тем самым определяется порядок, в котором эти тарелки будут вымыты, если у вас, конечно, нет желания каждый раз
# доставать тарелки из середины. Сначала берётся верхняя, потом следующая за ней и так дальше, пока тарелки не
# кончатся. И точно также при подготовке к ужину мы берём стопку чистых тарелок и выставляем их друг за другом.
# Каждый раз удобнее брать сверху. Принцип схож — есть упорядоченный набор элементов (прямо как массив или список),
# но производится всегда две операции — взять сверху или положить сверху. Как вы уже наверное догадались — это стек

# Рассмотрим другой пример, более приближенный к computer science. Вспомним рекурсию (она
# нам ещё не раз пригодится в этом модуле).
# Пусть у нас есть рекурсивная функция p(n). Мы вызываем её с аргументом p(5), она вызывает p(4), та, в свою очередь,
# снова уменьшает аргумент и так до нуля. Однако вычисления будут происходить наоборот! Сначала вычисляется p(0),
# затем p(1) доходя до самого первого вызова функции

# Задание 4.4.1
# Убедитесь в этом самостоятельно, написав функцию p(n), вызывающую эту же самую функцию с аргументом, уменьшенным
# на единицу, и после чего печатающей значение аргумента. Обратите внимание на описанный порядок действий и
# наличие условие выхода из рекурсии.
# def p(n):
#     if n <= 0:
#         return
#     else:
#         p(n - 1)
#         print(n)
# p(10)
#
# Здесь мы видим, что сначала выполнились действия последней функции в порядке вызовов, затем предпоследней
# и т. д., пока не дойдём до первого.
# Такой принцип имеет общепринятое название — LIFO — Last In First Out (последний вошел — первый вышел). И именно
# этот принцип реализует стек
# Иными словами, стек — это структура данных, реализующая LIFO
#
#
# 1 Вставка элемента в стек (push)
# Работает за O(1), если стек реализован через список и, в среднем, также O(1), если реализован через динамический массив.
#
# 2 Удаление верхнего элемента из стека (pop)
# Так же, как и вставка, удаление верхнего элемента происходит за O(1). Действительно, в массиве удаление последнего
# элемента происходит за константное время, как и в списке, если он двусвязный.
#
# 3 Получение значения последнего элемента без удаления (top)
# Аналогично предыдущим операциям получение значения последнего элемента происходит за O(1).
#
# 4 Общий размер стека (size)
# Здесь уже всё зависит от реализации. В случае односвязного списка O(1), если это значение хранится в самой
# структуре, или, O(n) если нужен проход по всем элементам для их пересчёта. В массиве операция получения размера
# занимает константное время.

# Задание 4.4.2
# Какую верхнюю границу сложности (худший случай) будет иметь вставка элемента в стек, если он реализован через
# динамический массив. Необходимо вспомнить особенности расширения массивов
# O(n)

# Наверняка вы не раз сталкивались с предупреждением от среды разработки или ошибкой от компилятора, связанной с
# неправильной расстановкой скобок.Сейчас мы посмотрим, как можно реализовать проверку строки на корректную
# расстановку скобок с помощью стека.
# Примем за корректную расстановку скобок такую, что для каждой открывающей существует закрывающая скобка — такая, что
# находится на одном «уровне» с ней.Примеры:
# ()
# (()())
# (()(()(()())))
# Наличие любой открытой, но не закрытой скобки является ошибкой.Ровно как и наличие закрывающей скобки без открывающей.
# Напишем функцию par_checker(string), которая проверяет строку string на корректность расстановки скобок.
# def par_checker(string):
#     stack = []  # инициализируем стек
#     for s in string:  # читаем строку посимвольно
#         if s == "(":  # если открывающая скобка,
#             stack.append(s)  # добавляем её в стек
#         elif s == ")":
#             # если встретилась закрывающая скобка, то проверяем,
#             # пуст ли стек и является ли верхний элемент открывающей скобкой
#             if len(stack) > 0 and stack[-1] == "(":
#                 stack.pop()  # удаляем из стека
#             else:  # иначе завершаем функцию с False
#                 return False
#     # если стек пустой, то незакрытых скобок не осталось
#     # значит возвращаем True, иначе - False
#     return len(stack) == 0
# Так как функция проверяет вхождение только скобок, то наличие других символов эту функцию не затронет.Убедитесь в этом
# самостоятельно

# Задание 4.4.4
# Что будет являться результатом работы функции par_checker при следующей входной строке?
# (5+6)*(7+8)/(4+3)
# print(par_checker('(5+6)*(7+8)/(4+3)'))

# Задание 4.4.5
# Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.
# Для реализации такого алгоритма может быть полезным создание словаря, в котором закрывающая скобка —
# ключ, открывающая — значение
# def par_checker(string):
#     dic = {'(':')', '[':']'}
#     stack = []  # инициализируем стек
#     for s in string:  # читаем строку посимвольно
#         for key_d, value_d in dic.items():
#             if s == key_d:  # если открывающая скобка,
#                 stack.append(s)  # добавляем её в стек
#             elif s == value_d:
#             # если встретилась закрывающая скобка, то проверяем,
#             # пуст ли стек и является ли верхний элемент открывающей скобкой
#                 if len(stack) > 0 and stack[-1] == key_d:
#                     stack.pop()  # удаляем из стека
#                 else:  # иначе завершаем функцию с False
#                     return False
#     # если стек пустой, то незакрытых скобок не осталось
#     # значит возвращаем True, иначе - False
#     return len(stack) == 0
#
# print(par_checker('(5+6)*[7+8]/(4+3)'))
# print(par_checker('(5+6]*[7+8)/(4+3)'))
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# pars = {")": "(", "]": "["}
# def par_checker_mod(string):
#     stack = []
#     for s in string:
#         if s in pars.values():
#             stack.append(s)
#         elif s in pars.keys():
#             if len(stack) > 0 and stack[-1] == pars[s]:
#                 stack.pop()
#             else:
#                 return False
#     return len(stack) == 0
# print(par_checker_mod('(5+6)*[7+8]/(4+3)'))
# print(par_checker_mod('(5+6]*[7+8)/(4+3)'))
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Очередь
# Другой вид последовательности, который скорее всего более привычен в бытовом смысле — это очередь.
# В отличие от стека он работает по принципу FIFO — First In First Out (первый вошёл — первый вышел).
# Прямо как в любимой всеми очереди к врачу, например
#
# Очередь может быть реализована как на массивах, так и на списках. В связи с наличием динамического массива в
# Python (list) попробуем построить очередь, используя эту структуру данных. Она имеет своё ограничение из-за того,
# что удаление из конца или вставка элемента в начало имеют сложность O(n)
#
# Чтобы обойти это ограничение, зафиксируем несколько свойств очереди:
# - Определим максимальную длину очереди — N_max.
# - При переполнении будем запрещать добавление элементов в очередь.
# - Зафиксируем два указателя:  head (начало) и tail (хвост) очереди.
# - Закольцуем очередь таким образом, что если указатель tail >= n_max, то мы перемещаем его в начало
# По такой схеме может получиться так, что начало очереди в конце списка, а хвост — в его начале
#
# Для очереди можно определить несколько операций:
#
# 1. Вставка элемента в хвост очереди (push).
# 2. Получение элемента из начала очереди (top).
# 3. Удаление элемента из начала очереди (pop).
# 4. Проверка наличия элементов в очереди (is_empty).
# 5. Получение размера очереди (size).
# Все они выполняются за O(1). И это то, что нужно!

# Попробуем создать обработчик задач на бесконечном цикле с использованием очереди:
# Создадим класс Queue — нужная нам очередь
# class Queue:
#     # Конструктор нашего класса, в нём происходит нужная инициализация объекта
#     def __init__(self, max_size):
#         self.max_size = max_size  # размер очереди
#         self.task_num = 0  # будем хранить сквозной номер задачи
#
#         self.tasks = [0 for _ in range(self.max_size)]  # инициализируем список с нулевыми элементами
#         self.head = 0  # указатель на начало очереди
#         self.tail = 0  # указатель на элемент следующий за концом очереди
#
#     # !!! Класс далее нужно дополнить методами !!!
#
#     # Задание 4.4.6
#     # Добавьте в класс Queue метод is_empty, который проверяет наличие элементов в очереди, используя указатели head и
#     # tail.Запрещается использование функции len(list_), так как ее сложность O(n).
#     def is_empty(self):
#         return self.head == self.tail and self.tasks[self.head] == 0
#
#     # Задание 4.4.7
#     # Добавьте в класс Queue метод size, который возвращает текущий размер очереди.Учтите, что необходимо рассмотреть
#     # несколько случаев: когда очередь пустая, когда очередь полная(какому условию соответствует?), а также отдельное
#     # внимание стоит обратить на тот случай, когда хвост очереди переместился в начало списка(закольцевался)
#     def size(self):
#         if self.is_empty():           # случай пустой очереди
#             return 0
#         elif self.head == self.tail:  # если очередь не пуста, но указатели совпадают
#             return self.max_size
#         elif self.head > self.tail:   # если хвост очереди в начале списка
#             return self.max_size - self.head + self.tail
#         else:                         # хвост очереди правее начала
#             return self.tail - self.head
#
#     # Задание 4.4.8
#     # Добавьте в класс Queue метод add, который добавляет задачу в конец очереди.Также учтите, что размер массива
#     # ограничен и при достижении этого предела, необходимо перенести указатель в положение 0.
#     # После добавления задачи в очередь, она должна вывести уведомление об этом в формате:
#     def add(self):
#         self.task_num += 1                      # увеличиваем порядковый номер задачи
#         self.tasks[self.tail] = self.task_num   # добавляем его в очередь
#         print(f"Задача №{self.tasks[self.tail]} добавлена")
#
#         # увеличиваем указатель на 1 по модулю максимального числа элементов
#         # для зацикливания очереди в списке
#         self.tail = (self.tail + 1) % self.max_size
#
#     # Задание 4.4.9
#     # Добавьте в класс Queue метод show, печатающий информацию о приоритетной задаче в формате
#     def show(self):
#         print(f"Задача №{self.tasks[self.head]} в приоритете")
#     # Задание 4.4.10
#     # Добавьте в класс Queue метод do, которая печатает в консоль задачу (=выполняет ее) и, соответственно,
#     # удаляет ее из очереди, присваивая ей значение 0. Формат вывода:
#     def do(self):
#         print(f"Задача №{self.tasks[self.head]} выполнена")
#
#         # после выполнения зануляем элемент по указателю
#         self.tasks[self.head] = 0
#         # и циклично перемещаем указатель
#         self.head = (self.head + 1) % self.max_size
#
#
# # Используем класс
# size = int(input("Определите размер очереди: "))
# q = Queue(size)
#
# while True:
#     cmd = input("Введите команду:")
#     if cmd == "empty":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             print("В очереди есть задачи")
#     elif cmd == "size":
#         print("Количество задач в очереди:", q.size())
#     elif cmd == "add":
#         if q.size() != q.max_size:
#             q.add()
#         else:
#             print("Очередь переполнена")
#     elif cmd == "show":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             q.show()
#     elif cmd == "do":
#         if q.is_empty():
#             print("Очередь пустая")
#         else:
#             q.do()
#     elif cmd == "exit":
#         print(q.tasks)  # выведем очередь в косоль: [0, 0, 0, 0, 0, 0, 7, 8, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
#         for _ in range(q.size()):
#             q.do()
#         print("Очередь пустая. Завершение работы")
#         break
#     else:
#         print("Введена неверная команда")
#     # Итак, первым делом реализуем проверку наличия элементов в очереди.

# Графы
# Граф — это структура, имеющая узлы (вершины графа) и связи между ними (рёбра)

# Задание 4.5.1
# Представьте эту часть схемы в виде графа и создайте список смежности, используя словарь

G = {'Адмиралтейская' : ['Садовая'],
     'Садовая' : ['Адмиралтейская', 'Сенная площадь', 'Спасская', 'Звенигородская'],
     'Сенная площадь' : ['Садовая', 'Спасская'],
     'Спасская' : ['Садовая', 'Сенная площадь', 'Достоевская'],
     'Достоевская' : ['Спасская', 'Владимирская'],
     'Владимирская' : ['Достоевская', 'Спасская'],
     'Пушкинская' : ['Владимирская', 'Звенигородская'],
     'Звенигородская' : ['Садовая', 'Пушкинская']}

# Граф, помимо прочего, может быть взвешенным — каждое ребро может иметь свой вес в графе.
# Такой граф можно представить в виде словаря словарей, где значение ключа представляет собой вес ребра.
# Любой невзвешенный граф имеет одинаковый вес рёбер, поэтому можем представить один из примеров выше в виде «словаря словарей», несмотря на то, что все «веса» рёбер одинаковы
# G = {0 : {1 : 1,
#           2 : 1,
#           3 : 1},
#      1 : {0 : 1,
#           2 : 1},
#      2 : {0 : 1,
#           1 : 1},
#      3 : {0 : 1}}

# Задание 4.5.2
# Возьмите граф из предыдущего задания (с картой метро) и постройте из него взвешенный граф. В качестве весов
# используйте время, необходимое для того, чтобы доехать (или перейти) с одной станции на другую. Для этого
# можно воспользоваться сервисом Яндекс.Метро.
G = {'Адмиралтейская' : {'Садовая' : 4},
     'Садовая' : {'Адмиралтейская' : 4, 'Сенная площадь' : 4, 'Спасская' : 3, 'Звенигородская' : 5},
     'Сенная площадь' : {'Садовая' : 4, 'Спасская' : 4},
     'Спасская' : {'Садовая' : 3, 'Сенная площадь' : 4, 'Достоевская' : 6},
     'Достоевская' : {'Спасская': 6, 'Владимирская' : 3},
     'Владимирская' : {'Достоевская' : 3, 'Пушкинская' : 4},
     'Пушкинская' : {'Владимирская' : 4, 'Звенигородская' : 3},
     'Звенигородская' : {'Садовая' : 5, 'Пушкинская' : 3}}

# Алгоритм Дейкстры
# D = {k : 100 for k in G.keys()}
# D["Адмиралтейская"] = 0
# U = {k : False for k in G.keys()}

# D = {k : 100 for k in G.keys()}  # расстояния
# start_k = 'Адмиралтейская'  # стартовая вершина
# D[start_k] = 0  # расстояние от неё до самой себя равно нулю
# U = {k: False for k in G.keys()}  # флаги просмотра вершин
# P = {k: None for k in G.keys()}
#
# for _ in range(len(D)):
#     # выбираем среди непросмотренных наименьшее по расстоянию
#     min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])
#
#     for v in G[min_k].keys():              # проходимся по всем смежным вершинам
#         if D[v] > D[min_k] + G[min_k][v]:  # если расстояние от текущей вершины меньше
#             D[v] = D[min_k] + G[min_k][v]  # то фиксируем его
#             P[v] = min_k                   # и записываем как предок
#     U[min_k] = True  # просмотренную вершину помечаем
# print(D)  # {'Адмиралтейская': 0, 'Садовая': 4, 'Сенная площадь': 8, 'Спасская': 7, 'Достоевская': 13,
#           # 'Владимирская': 16, 'Пушкинская': 12, 'Звенигородская': 9}
# print(P)  # {'Адмиралтейская': None, 'Садовая': 'Адмиралтейская', 'Сенная площадь': 'Садовая', 'Спасская': 'Садовая',
#           # 'Достоевская': 'Спасская', 'Владимирская': 'Пушкинская', 'Пушкинская': 'Звенигородская',
#           # 'Звенигородская': 'Садовая'}

# Алгоритм Дейкстры можно модифицировать таким образом, что можно определить не только величину пути,
# но ещё и сами вершины минимального пути.
# Для этого определим ещё один словарь P, в котором будем для каждой вершины хранить вершину-предок
# с минимальным расстоянием.
# P = {k : None for k in G.keys()}

# Задание 4.5.3
# Модифицируйте алгоритм Дейкстры таким образом, что в массив P по соответствующему ключу будет записываться
# предок с минимальным расстоянием, если это необходимо.
# см. выше
# pointer = some_station # куда должны прийти
# path = [] # список с вершинами пути
# while pointer is not None: # перемещаемся, пока не придём в стартовую точку
#    path.append(pointer)
#    pointer = P[pointer]
#
# path.reverse() # разворачиваем путь
# for v in path:
#     print(v)

# Задание 4.5.4
# Запишите станции в порядке вывода через запятую и пробел (в именительном падеже с заглавной буквы), если нужно
# найти кратчайший путь от Адмиралтейской до Владимирской
# Адмиралтейская, Садовая, Звенигородская, Пушкинская, Владимирская
# 4, 5, 3, 4

# Деревья
# Один из наиболее часто используемых подвидов графов — это деревья.
# Чтобы граф считался деревом, необходимо выполнение нескольких условий:
#   1. Граф должен быть связным — не должно отсутствовать вершин без рёбер.
#   2. Должны отсутствовать циклы.
#   3. Часто под деревьями подразумеваются только неориентированные и невзвешенные графы.
# При соблюдении этих условий граф можно визуально представить в виде структуры, напоминающей обычное дерево. Только, как правило, оно «растёт» вниз.
# В дереве можно выделить:
#   - корневой узел;
#   - потомков;
#   - лист или терминальный узел — узел, не имеющий потомков;
#   - внутренние узлы — некорневые узлы, имеющие хотя бы одного потомка
#
# В зависимости от максимального количества потомков в одной вершине различают:
#   - бинарные;
#   - тернарные деревья;
#   - n-арные деревья (с максимальным количеством потомков n);
#   - 2-3 деревья, 2-3-4, в которых помимо увеличенного количества потомков в самом узле может храниться больше данных.
class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left_child = None
        self.right_child = None
    def insert_left(self, next_value):
        if self.left_child is None:
            self.left_child = BinaryTree(next_value)
        else:
            new_child = BinaryTree(next_value)
            new_child.left_child = self.left_child
            self.left_child = new_child
        return self
    def insert_right(self, next_value):
        if self.right_child is None:
            self.right_child = BinaryTree(next_value)
        else:
            new_child = BinaryTree(next_value)
            new_child.right_child = self.right_child
            self.right_child = new_child
        return self
    def pre_order(self):
        print(self.value)                 # процедура обработки
        if self.left_child is not None:   # если левый потомок существует
            self.left_child.pre_order()   # рекурсивно вызываем функцию
        if self.right_child is not None:  # если правый потомок существует
            self.right_child.pre_order()  # рекурсивно вызываем функцию
    def post_order(self):
        if self.left_child is not None:   # если левый потомок существует
            self.left_child.post_order()   # рекурсивно вызываем функцию
        if self.right_child is not None:  # если правый потомок существует
            self.right_child.post_order()  # рекурсивно вызываем функцию
        print(self.value)                 # процедура обработки
    def in_order(self):
        if self.left_child is not None:  # если левый потомок существует
            self.left_child.in_order()  # рекурсивно вызываем функцию
        print(self.value)  # процедура обработки
        if self.right_child is not None:  # если правый потомок существует
            self.right_child.in_order()  # рекурсивно вызываем функцию

# Задание 4.5.5
# Реализуйте структуру дерева при помощи класса BinaryTree
# BT = BinaryTree(2)
node_root = BinaryTree(2).insert_left(7).insert_right(5)
node_7 = node_root.left_child.insert_left(2).insert_right(6)
node_6 = node_7.right_child.insert_left(5).insert_right(11)
node_5 = node_root.right_child.insert_right(9)
node_9 = node_5.right_child.insert_right(4)

# Обход дерева
# Различают два основных способа обхода:
#    1. Поиск в глубину (depth-first search, DFS). Его основная суть заключается в том, что проходя по
#       каждому узлу мы сначала идём в его потомка, а потом возвращаемся обратно — это обход с возвратом. Такой поиск
#       бывает трёх видов:
#         - префиксный (pre-order);
#         - постфиксный (post-order);
#         - инфиксный (in-order).
#    2. Поиск в ширину (breadth-first search, BFS). Такой обход осуществляется в обходе уровня за уровнем.
# node_root.pre_order()
# 2
# 7
# 2
# 6
# 5
# 11
# 5
# 9
# 4

# Задание 4.5.6
# Напишите метод постфиксного обхода в глубину.
# node_root.post_order()
# 2
# 5
# 11
# 6
# 7
# 4
# 9
# 5
# 2

# node_root.in_order()
# 2
# 7
# 5
# 6
# 11
# 2
# 5
# 9
# 4

# Связанный список
# class Node:  # класс элемента
#     def __init__(self, value=None, next_=None):  # инициализируем
#         self.value = value  # значением
#         self.next = next_  # и ссылкой на следующий элемент
#     def __str__(self):
#         return "Node value = " + str(self.value)
#
# class LinkedList:  # класс списка
#     def __init__(self):  # инициализируем пустым
#         self.first = None
#         self.last = None
#     def clear(self):  # очищаем список
#         self.__init__()
#     def __str__(self):  # функция печати
#         R = ''
#         pointer = self.first         # берём первый указатель
#         while pointer is not None:   # пока указатель не станет None
#             R += str(pointer.value)  # добавляем значение в строку
#             pointer = pointer.next   # идём дальше по указателю
#             if pointer is not None:  # если он существует, добавляем пробел
#                 R += ' '
#         return R
#     def __iter__(self):  # объявляем класс как итератор
#         self.current = self.first  # в текущий элемент помещаем первый
#         return self  # возвращаем итератор
#     def __next__(self):  # метод перехода
#         if self.current is None:  # если текущий стал последним
#             raise StopIteration  # вызываем исключение
#         else:
#             node = self.current  # сохраняем текущий элемент
#             self.current = self.current.next  # совершаем переход
#             return node  # и возвращаем сохранённый
#     def pushleft(self, value):
#         if self.first is None:
#             self.first = Node(value)
#             self.last = self.first
#         else:
#             new_node = Node(value, self.first)
#             self.first = new_node
#     def pushright(self, value):
#         if self.first is None:
#             self.first = Node(value)
#             self.last = self.first
#         else:
#             new_node = Node(value)
#             self.last.next = new_node
#             self.last = new_node
#     def popleft(self):
#         if self.first is None:  # если список пустой, возвращаем None
#             return None
#         elif self.first == self.last:  # если список содержит только один элемент
#             node = self.first  # сохраняем его
#             self.__init__()  # очищаем
#             return node  # и возвращаем сохранённый элемент
#         else:
#             node = self.first  # сохраняем первый элемент
#             self.first = self.first.next  # меняем указатель на первый элемент
#             return node  # возвращаем сохранённый
#     def popright(self):
#         if self.first is None:  # если список пустой, возвращаем None
#             return None
#         elif self.first == self.last:  # если список содержит только один элемент
#             node = self.first  # сохраняем его
#             self.__init__()  # очищаем
#             return node  # и возвращаем сохраненный элемент
#         else:
#             node = self.last  # сохраняем последний
#             pointer = self.first  # создаём указатель
#             while pointer.next is not node:  # пока не найдём предпоследний
#                 pointer = pointer.next
#             pointer.next = None  # обнуляем указатели, чтобы
#             self.last = pointer  # предпоследний стал последним
#             return node  # возвращаем сохранённый
#     def __len__(self):
#         count = 0
#         pointer = self.first
#         while pointer is not None:
#             count += 1
#             pointer = pointer.next
#         return count

# Задание 4.6.2
# Напишите функцию pushright, которая добавляет элемент в правую часть списка
#
# Задание 4.6.3
# Как будет выглядеть список после выполнения последовательности операций?
# LL = LinkedList()
# LL.pushright(1)
# LL.pushleft(2)
# LL.pushright(3)
# LL.popright()
# LL.pushleft(4)
# LL.pushright(5)
# LL.popleft()
# print(LL)
# print(LL.__len__())

# Линейный поиск
# def find(array, element):
#     for i, a in enumerate(array):
#         if a == element:
#             return i
#     return False
#
# array = list(map(int, input().split()))
# element = int(input())
#
# print(find(array, element))
# В худшем случае этот алгоритм работает за O(n), потому что, если элемент не входит в массив, придётся провести
# n сравнений. Все они не увенчаются успехом

# Задание 4.7.1
# Напишите функцию count, которая возвращает количество вхождений элемента в массив
# def count(array, element):
#     cnt = 0
#     for i in array:
#         if i == element:
#             cnt += 1
#     return cnt
# print(count([1, 12, 3, 2, 1, 34, 45, 11], 1))


# Двоичный поиск
# def binary_search(array, element, left, right):
#     if left > right:  # если левая граница превысила правую,
#         return False  # значит, элемент отсутствует
#     middle = (right + left) // 2  # находим середину
#     if array[middle] == element:  # если элемент в середине
#         return middle  # возвращаем этот индекс
#     elif element < array[middle]:  # если элемент меньше элемента в середине
#         # рекурсивно ищем в левой половине
#         return binary_search(array, element, left, middle - 1)
#     else:  # иначе в правой
#         return binary_search(array, element, middle + 1, right)
# element = int(input())
# array = [i for i in range(1, 100)]  # 1,2,3,4,...
# # запускаем алгоритм на левой и правой границе
# print(binary_search(array, element, 0, 99))

# Сортировка
# В заключительной части модуля мы рассмотрим некоторые алгоритмы сортировки:
# 1. Наивная сортировка (чтобы показать, как делать не стоит).
# 2. Сортировка выбором (чуть менее наивный, но далёк от идеала).
# 3. Сортировка пузырьком (пожалуй, самый понятный в реализации, но далеко не самый эффективный).
# 4. Сортировка вставками (неплохо).
# 5. Сортировка слиянием (заметно лучше).
# 6. Быстрая сортировка (почти идеально!)

# Наивная сортировка
# основная суть заключается в том, чтобы постоянно перемешивать массив, пока не получим подходящую последовательность…
# сложность О(n!)
# import random  # модуль, с помощью которого перемешиваем массив
# # пусть имеем массив всего лишь из 9 элементов
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# is_sort = False  # станет True, если отсортирован
# count = 0  # счётчик количества перестановок
# while not is_sort:  # пока не отсортирован
#     count += 1  # прибавляем 1 к счётчику
#     random.shuffle(array)  # перемешиваем массив
#     # проверяем отсортирован ли
#     is_sort = True
#     for i in range(len(array) - 1):
#         if array[i] > array[i + 1]:
#             is_sort = False
#             break
# print(array)
# # [1, 2, 3, 4, 5, 6, 7, 8, 9]
# print(count)
# # 290698 / 308420 / 24009 / 667427

# Рекурсия - факториал
# def check(n):
#     cnt = 1
#     for i in range(1, n + 1):
#         print(i)
#         cnt = cnt * i
#     return cnt
#     # if n >= 1: # in range(101):
#     #     return check(n-1)
# print(check(100))
# 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000

# Сортировка выбором
# Следующее решение «в лоб» — каждый раз искать минимальный элемент и ставить его в начало
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# cnt = 0
# for i in range(len(array)): # проходим по всему массиву
#     idx_min = i # сохраняем индекс предположительно минимального элемента
#     for j in range(i+1, len(array)):
#         cnt += 1
#         if array[j] < array[idx_min]:
#             idx_min = j
#     if i != idx_min: # если индекс не совпадает с минимальным, меняем
#         array[i], array[idx_min] = array[idx_min], array[i]
# print(array)
# print(cnt)
# На каждом шаге мы имеем отсортированную (слева) и неотсортированную часть (справа). Ищется минимальный элемент в
# неотсортированной части и меняется местами с элементом в начале неотсортированной части. И так продолжается,
# пока не закончится внешний цикл.

# Задание 4.8.2
# Посчитайте количество сравнений элементов списка, которые производятся в алгоритме выбором из примера
# cnt = 36

# Задание 4.8.3
# Модифицируйте описанный алгоритм для сортировки по убыванию.
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# cnt = 0
# for i in range(len(array)): # проходим по всему массиву
#     idx_max = i # сохраняем индекс предположительно максимального элемента
#     for j in range(i + 1, len(array)):
#         cnt += 1
#         if array[j] > array[idx_max]:
#             idx_max = j
#     if i != idx_max: # если индекс не совпадает с максимальным, меняем
#         array[i], array[idx_max] = array[idx_max], array[i]
# print(array)
# print(cnt)

# Сортировка пузырьком
# Суть сводится к тому, что максимальные элементы шаг за шагом «всплывают» вправо — в отсортированную часть массива.
# И по ходу совершаются ещё перестановки, если это необходимо, ведь каждый раз мы сравниваем только соседние элементы!
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7, 19, 13, 11]
# cnt = 0
# for i in range(len(array)):
#     for j in range(len(array) - i - 1):
#         cnt += 1
#         if array[j] > array[j + 1]:
#             array[j], array[j + 1] = array[j + 1], array[j]
# print(array)
# print(cnt)
# Алгоритм сортировки как пузырьком, так и выбором, имеет среднюю сложность O(n2), потому что мы имеем два вложенных цикла,
# каждый из которых, в среднем, проходится по половине всего количества элементов.На первой итерации проверяется N - 1
# условие, на второй N - 2 и т.д., пока на последней итерации не останется только 1 условие(сравнить первый и второй
# элементы).Можно убедиться, что среднее количество будет равно ~N/2 на каждой итерации, которых N.Это и приводит нас к
# квадратичной сложности обоих алгоритмов.
# Однако пузырёк всё - таки побеждает, потому что на каждую итерацию тратится # чуть - чуть меньше времени.
# Пузырёк удобен, когда структура имеет не очень большой размер и очень важна скорость написания кода.В таком случае
# пузырёк идеален — два цикла, одно условие и один swap(перестановка двух элементов).Однако на более крупных массивах
# пузырёк сильно проигрывает другим алгоритмам

# Сортировка вставками
# Готовы сами написать сортировку? Никаких сомнений — готовы! Что должен сделать алгоритм?
#     1. В начале итерации устанавливается ведущий элемент. На первой итерации — самый первый элемент и по умолчанию
#        он считается уже отсортированным.
#     2. Сохраняем ведущий элемент в дополнительную переменную (красный квадрат в анимации).
#     3. Далее происходит поиск места, куда должен встать ведущий элемент в уже отсортированной (левой) части массива.
#        Можно, например, использовать цикл while с условием достижения границы и/или успешным нахождением элемента.
#        Пока условие цикла выполняется, происходит сдвиг каждого элемента вправо.
#     4. По завершении цикла сохранённое значение переменной помещается на освободившееся место. Алгоритм завершается

# Задание 4.8.4
# Реализуйте алгоритм сортировки вставками
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7] # [2, 3, 1, 4, 6, 5, 9, 8, 7, 19, 13, 11]
# cnt = 0
# for i in range(1, len(array)):
#     x = array[i]
#     idx = i
#     while idx > 0:
#         cnt += 1
#         if array[idx-1] <= x:
#             break
#         array[idx] = array[idx-1]
#         idx -= 1
#     array[idx] = x
# print(array)
# print(cnt)

# Задание 4.8.5
# Вам нужно вставить строку count += 1 так, чтобы код считал количество сравнений элементов списка. В ответе напишите,
# чему равно количество сравнений элементов списка, которые производятся в алгоритме сортировки вставками
# count = 0
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7]
# for i in range(1, len(array)):
#     x = array[i]
#     idx = i
#     while idx > 0:
#         count += 1
#         if (array[idx - 1] <= x):
#             break
#         array[idx] = array[idx - 1]
#         idx -= 1
#     array[idx] = x
# print(count)

# Сортировка слиянием
# Сортировка слиянием основана на принципе «разделяй и властвуй». Без шуток. Сначала делим массив пополам (или почти
# пополам, если в массиве нечётное количество элементов). И снова пополам. И снова. Ещё раз. Пока не устанете. Ладно,
# на самом деле программа сама это сделает, если использовать рекурсию. А выход из рекурсии случится тогда, когда
# отделённый кусок массива станет размером 1, т. е. сократится до одного элемента. А один элемент уж точно можно
# считать отсортированным относительно себя. Полпути сортировки можно считать пройденной
# Нам нужно склеивать обратно расщепленные части массива, потому она и называется сортировкой слиянием. Итак, имеем
# два одиночных элемента — сравниваем их и возвращаем на предыдущий уровень рекурсии в нужном порядке.
# Когда имеем больше элементов в каждой из частей, подлежащих слиянию, нужно быть предельно аккуратным:
#     1. Сравниваем первые элементы.
#     2. В результирующий массив записываем наименьший.
#     3. Сравниваем первый элемент в нетронутом и второй элемент из другой части.
#     4. Сравниваем — склеиваем в результат.
#     5. И так продолжается, пока не будет достигнут конец одной из частей.
#     6. Последний штрих — в результирующий массив записать все элементы из ещё пока непустой части.
#     7. Вернуть результат на предыдущий уровень рекурсии

# Задание 4.8.6
# Реализуйте алгоритм сортировки слиянием
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7, 15]
# def merge_sort(array):
#     if len(array) > 1:
#         mid = len(array) // 2
#         left = array[:mid]
#         right = array[mid:]
#         merge_sort(left)
#         merge_sort(right)
#
#         i = j = k = 0
#         while i < len(left) and j < len(right):
#             if left[i] < right[j]:
#                 array[k] = left[i]
#                 i += 1
#             else:
#                 array[k] = right[j]
#                 j += 1
#             k += 1
#
#         while j < len(right):
#             array[k] = right[j]
#             j += 1
#             k += 1
#
#         while i < len(left):
#             array[k] = left[i]
#             i += 1
#             k += 1
#
# merge_sort(array)
# print(array)

# Быстрая сортировка
# Алгоритм выполняется рекурсивно следующим образом:
#     1. Выбирается ведущий элемент (есть несколько вариантов, о которых поговорим чуть позже).
#     2. Две части массива сортируются только на основе этого ведущего элемента.
#     3. Происходит последовательный обмен значениями элементов. Вопрос в том, какие элементы обменивать. Сначала
#        происходит поиск слева направо до первого элемента, который превосходит по своему значению ведущий элемент.
#        Затем массив просматривается справа налево в поисках элемента, который меньше ведущего.
#        Когда такие элементы найдены, происходит их обмен.
#     4. Таким образом, в левой части массива имеются элементы только меньше ведущего, а в правой — только больше.
#     5. Функция рекурсивно применяется к получившимся частям массива, если их размеры превосходят один элемент
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7, 15]
# def qsort(array, left, right):
#     middle = (left + right) // 2
#
#     p = array[middle]
#     i, j = left, right
#     while i <= j:
#         while array[i] < p:
#             i += 1
#         while array[j] > p:
#             j -= 1
#         if i <= j:
#             array[i], array[j] = array[j], array[i]
#             i += 1
#             j -= 1
#
#     if j > left:
#         qsort(array, left, j)
#     if right > i:
#         qsort(array, i, right)

# Cуществует несколько способов улучшить работу быстрой сортировки, чтобы даже в худшем случае не доводить затраты по
# времени до O(n2):
#     1. Нахождение среднего между первым и последним элементом массива.
#     2. Нахождение медианы между первым, средним и последним элементами.
#     3. Наиболее оптимально находить медиану всей последовательности, но это может быть слишком затратно.
#     4. Рандомный элемент.
# Как правило, на практике в качестве ведущего элемента выбирается случайно выбранный из всей последовательности.
# Благодаря такому выбору вероятность попасть на минимальный (максимальный) элемент достаточно быстро стремится к нулю,
# что особенно справедливо на очень больших массивах

# Задание 4.8.7
# Модифицируйте алгоритм быстрой сортировки таким образом, чтобы ведущий элемент выбирался как случайный среди
# подмассива, который сортируется на данном этапе. Воспользуйтесь функцией из пакета random
# import random
#
# array = [2, 3, 1, 4, 6, 5, 9, 8, 7, 15]
# def qsort(array, left, right):
#     middle = random.choice(array[left: right + 1])
#     # middle = (left + right) // 2
#
#     p = array[middle]
#     i, j = left, right
#     while i <= j:
#         while array[i] < p:
#             i += 1
#         while array[j] > p:
#             j -= 1
#         if i <= j:
#             array[i], array[j] = array[j], array[i]
#             i += 1
#             j -= 1
#
#     if j > left:
#         qsort(array, left, j)
#     if right > i:
#         qsort(array, i, right)
#
# qsort(array, 0, len(array)-1)
# print(array)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!Итоговое задание !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Чат-бот конвертации валют !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# import requests
# r = requests.get(
#     'https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')  # делаем запрос на сервер по переданному адресу
# print(r.content)
# b'<p>Bacon ipsum dolor amet leberkas pancetta t-bone buffalo porchetta pig.  Brisket burgdoggen shoulder flank corned
# beef hamburger t-bone pork landjaeger tenderloin filet mignon ham hock beef ribs.  Turkey burgdoggen meatloaf,
# buffalo beef swine meatball ribeye chuck chicken leberkas.  Jerky landjaeger short ribs meatball turducken,
# burgdoggen biltong.  Pork tongue ground round capicola meatball.</p>\n<p>Landjaeger tongue venison, bresaola
# t-bone shankle turkey.  Spare ribs tenderloin biltong jowl.  Short loin jowl picanha chicken strip steak pancetta
# chuck sirloin.  Brisket spare ribs short loin t-bone.  Meatball swine pastrami, t-bone landjaeger doner bacon salami
# sausage jerky.  Prosciutto fatback ball tip chislic turkey.</p>\n<p>Turkey drumstick cupim short ribs chislic.
# Buffalo venison tri-tip bresaola meatloaf tenderloin chuck.  Pancetta kielbasa andouille boudin spare ribs chislic
# buffalo capicola shankle corned beef meatball ground round jerky brisket.  Picanha andouille ball tip pork chop,
# capicola ground round biltong t-bone sausage short loin.</p>\n'

# import requests
# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')
# print(r.status_code)  # узнаем статус полученного ответа
# 200

# Есть несколько категорий ответов, например:
#     200, 201, 202 и т. д. — ответы, которые говорят, что с запросом всё хорошо и ответ приходит правильный, т. е.
#                             его можно обрабатывать и как-либо взаимодействовать с ним. На самом деле почти все
#                             серверы всегда в ответ шлют именно ответ 200, а не какой-либо другой из этой же категории.
#     300, 301 и т. д. — ответы, которые говорят, что вы будете перенаправлены на другой ресурс (необязательно на этом
#                        же сервере).
#     400, 401 и т. д. — ответы, которые говорят, что что-то неправильно с запросом. Запрашивается либо несуществующая
#                        страница (всем известная 404 ошибка), либо же недостаточно прав для просмотра
#                        страницы (403) и т. д.
#     501, 502 и т. д. — ответы, которые говорят, что с запросом всё хорошо, но вот на сервере что-то сломалось,
#                        и поэтому нормальный ответ прийти не может.
# Со всеми типами ответов можно ознакомиться здесь: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status

# import requests
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')  # попробуем поймать json-ответ
# print(r.content)
# # b'["In est in, flank meatball non rump veniam turducken picanha voluptate adipisicing cillum corned beef.  Beef reprehenderit pork chop tenderloin, t-bone lorem consequat shank.  Ut velit elit deserunt enim ut, kevin ullamco irure ham hock quis corned beef consequat.  Meatball mollit ipsum buffalo labore beef dolore.  Short ribs voluptate in irure.  Pork loin in excepteur ipsum meatloaf, shank pariatur qui quis sausage dolor.  Commodo shoulder spare ribs occaecat, non cupidatat cillum eiusmod turducken pork dolore.","Bresaola veniam ex nostrud sunt exercitation short ribs est ut sed ea.  Magna eiusmod chislic id tail in velit, voluptate in.  Corned beef brisket sirloin, tail picanha fugiat minim pariatur eu.  Drumstick incididunt sed, reprehenderit officia doner short loin ut capicola tail tongue fugiat shank.  Culpa ut buffalo pork belly ribeye.  Ut cupim sunt, reprehenderit ea anim velit strip steak aliqua bresaola sausage.  Pancetta burgdoggen id landjaeger laborum commodo.","Aliqua nulla do esse voluptate drumstick shoulder ullamco excepteur porchetta cow mollit eiusmod kevin aliquip.  Meatloaf andouille boudin exercitation incididunt aliquip pastrami proident nisi pariatur.  Bresaola meatball elit incididunt, consectetur turducken rump chuck beef ribs jowl excepteur.  Cupidatat ut velit dolor beef ground round.  Ut dolore tempor ad sed.  Et kielbasa consectetur jowl ex rump aliquip picanha sed reprehenderit sirloin short ribs meatball.","Sunt pork loin corned beef ea, chicken mollit ipsum andouille ribeye eiusmod in rump commodo turducken do.  Id alcatra picanha short loin, sunt dolore short ribs laborum venison cupim fatback kevin est tri-tip.  Non commodo pastrami kielbasa est.  Ham hock quis pig porchetta, filet mignon minim mollit jowl ea cupidatat short ribs.  Short ribs pork chop elit kielbasa excepteur jowl doner mollit minim nostrud ham hamburger.  Ipsum pancetta shoulder, turducken sint meatloaf id kielbasa elit mollit consequat.","Cillum tri-tip ground round pastrami sirloin tongue beef ribs ut esse laborum doner officia cupim.  Jerky laborum mollit sirloin et consectetur cow meatball pig tail dolor officia anim.  Corned beef flank ipsum short loin.  Ut frankfurter hamburger strip steak mollit chuck."]'

# import requests
# import json  # импортируем необходимую библиотеку
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
# texts = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
# print(type(texts))  # проверяем тип сконвертированных данных
# for text in texts:  # выводим полученный текст. Но для того чтобы он влез в консоль, оставим только первые 50 символов.
#     print(text[:50], '\n')

# import requests
# import json
# r = requests.get('https://api.github.com')
# print(r.content)
# # b'{\n  "current_user_url": "https://api.github.com/user",\n  "current_user_authorizations_html_url": "https://github.com/settings/connections/applications{/client_id}",\n  "authorizations_url": "https://api.github.com/authorizations",\n  "code_search_url": "https://api.github.com/search/code?q={query}{&page,per_page,sort,order}",\n  "commit_search_url": "https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}",\n  "emails_url": "https://api.github.com/user/emails",\n  "emojis_url": "https://api.github.com/emojis",\n  "events_url": "https://api.github.com/events",\n  "feeds_url": "https://api.github.com/feeds",\n  "followers_url": "https://api.github.com/user/followers",\n  "following_url": "https://api.github.com/user/following{/target}",\n  "gists_url": "https://api.github.com/gists{/gist_id}",\n  "hub_url": "https://api.github.com/hub",\n  "issue_search_url": "https://api.github.com/search/issues?q={query}{&page,per_page,sort,order}",\n  "issues_url": "https://api.github.com/issues",\n  "keys_url": "https://api.github.com/user/keys",\n  "label_search_url": "https://api.github.com/search/labels?q={query}&repository_id={repository_id}{&page,per_page}",\n  "notifications_url": "https://api.github.com/notifications",\n  "organization_url": "https://api.github.com/orgs/{org}",\n  "organization_repositories_url": "https://api.github.com/orgs/{org}/repos{?type,page,per_page,sort}",\n  "organization_teams_url": "https://api.github.com/orgs/{org}/teams",\n  "public_gists_url": "https://api.github.com/gists/public",\n  "rate_limit_url": "https://api.github.com/rate_limit",\n  "repository_url": "https://api.github.com/repos/{owner}/{repo}",\n  "repository_search_url": "https://api.github.com/search/repositories?q={query}{&page,per_page,sort,order}",\n  "current_user_repositories_url": "https://api.github.com/user/repos{?type,page,per_page,sort}",\n  "starred_url": "https://api.github.com/user/starred{/owner}{/repo}",\n  "starred_gists_url": "https://api.github.com/gists/starred",\n  "topic_search_url": "https://api.github.com/search/topics?q={query}{&page,per_page}",\n  "user_url": "https://api.github.com/users/{user}",\n  "user_organizations_url": "https://api.github.com/user/orgs",\n  "user_repositories_url": "https://api.github.com/users/{user}/repos{?type,page,per_page,sort}",\n  "user_search_url": "https://api.github.com/search/users?q={query}{&page,per_page,sort,order}"\n}\n'

# import requests
# import json
# r = requests.get('https://api.github.com')
# d = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
# print(type(d))
# print(d['following_url'])  # обращаемся к полученному объекту как к словарю и попробуем напечатать одно из его значений
# # <class 'dict'>
# # https://api.github.com/user/following{/target}

# import requests
# r = requests.post('https://httpbin.org/post', data={'key': 'value'})  # отправляем POST-запрос
# print(r.content)  # содержимое ответа и его обработка происходит так же, как и с GET-запросами, разницы никакой нет
# # b'<html>\r\n<head><title>504 Gateway Time-out</title></head>\r\n<body>\r\n<center><h1>504 Gateway Time-out</h1></center>\r\n</body>\r\n</html>\r\n'

# import requests
# import json
# data = {'key': 'value'}
# r = requests.post('https://httpbin.org/post', json=json.dumps(
#     data))  # отправляем POST-запрос, но только в этот раз тип передаваемых данных будет JSON
# print(r.content)
# # b'{\n  "args": {}, \n  "data": "\\"{\\\\\\"key\\\\\\": \\\\\\"value\\\\\\"}\\"", \n  "files": {}, \n  "form": {}, \n  "headers": {\n    "Accept": "*/*", \n    "Accept-Encoding": "gzip, deflate", \n    "Content-Length": "22", \n    "Content-Type": "application/json", \n    "Host": "httpbin.org", \n    "User-Agent": "python-requests/2.30.0", \n    "X-Amzn-Trace-Id": "Root=1-6464d583-7a24b9354742eea11d5f3c06"\n  }, \n  "json": "{\\"key\\": \\"value\\"}", \n  "origin": "185.32.134.31", \n  "url": "https://httpbin.org/post"\n}\n'

# Задание 5.2.3
# Напишите программу, которая отправляет запрос на генерацию случайных текстов (используйте этот сервис:
# https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html).
# Выведите первый из сгенерированных текстов
# import requests
# # делаем запрос на сервер по переданному адресу
# r = requests.get('https://baconipsum.com/api/?type=all-meat&paras=3&start-with-lorem=1&format=html')
# print(r.content)

# import requests
# import json  # импортируем необходимую библиотеку
# r = requests.get('https://baconipsum.com/api/?type=meat-and-filler')
# texts = json.loads(r.content)  # делаем из полученных байтов Python-объект для удобной работы
# print(texts[0])
# Kevin picanha rump ipsum andouille tri-tip meatloaf ut beef ribs strip steak esse pariatur chicken.  Nulla corned
# beef ut, occaecat eu in shoulder sausage andouille labore.  Irure fatback corned beef ea.  Meatball meatloaf
# laboris brisket, velit in filet mignon cow veniam.  Porchetta pork nulla, short loin spare ribs ut tenderloin
# sunt alcatra voluptate ad incididunt.

# Что такое боты Telegram?
# Боты — это сторонние приложения, которые запускаются внутри Telegram
# Приведём краткий список того, что умеют делать боты:
#
# Получение индивидуальных уведомлений и новостей. Бот может работать как умная газета, которая будет отправлять
# интересующий вас контент, как только он будет опубликован.
# Интеграция с другими сервисам. Бот может дополнять чаты Telegram возможностями из внешних сервисов, например:
# Gmail Bot, GIF bot, IMDB bot, Wiki bot, Music bot, Youtube bot, GitHub bot.
# Создание собственных инструментов. Бот может предоставлять вам оповещения о различных действиях, прогнозы погоды,
# переводы, форматирование или другие услуги. Например: Markdown bot, Sticker bot, Vote bot, Like bot.

# Как работают боты?
# По сути, боты Telegram — это особые учётные записи, для которых не требуется дополнительный номер телефона.
# Пользователи могут взаимодействовать с ботами двумя способами:
#     1. Отправлять сообщения и команды ботам, открывая с ними чат или добавляя их в группы.
#     2. Отправлять запросы прямо из поля ввода, вводя @username бота и запрос. Это позволяет отправлять контент от
#        встроенных ботов прямо в любой чат, группу или канал

# Для того чтобы создать бота, есть … бот. :) Вам необходимо написать @BotFather и выполнить несколько простых шагов.
# Используйте команду /newbot, чтобы создать нового бота.
#
# Затем необходимо:
#     1. Установить имя (name) вашего бота.
#        Имя вашего бота отображается в контактной информации и в других местах.
#     2. Установить имя пользователя (username) вашего бота.
#        Имя пользователя — это короткое имя, которое будет использоваться для идентификации вашего бота и
#        обращения к нему. Имена пользователей состоят из 5–32 символов и нечувствительны к регистру, могут включать
#        только латинские символы, числа и символы подчёркивания. Имя пользователя вашего бота должно заканчиваться
#        на «bot», например, «tetris_bot» или «TetrisBot».
#     3. Получить токен (token).
#        Токен представляет собой строку вида 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw. Он необходим для
#        авторизации (подтверждения, что именно вы владелец этого бота, чтобы в программе было понятно, к какому
#        именно боту привязываются все обработчики) вашей программы, в которой реализована логика бота. Токен — это
#        пароль от вашего бота, поэтому храните свой токен в безопасности.
#        С более подробной информацией о возможностях @BotFather можно ознакомиться в официальной документации.

# @BotFather --> /newbot
# I can help you create and manage Telegram bots. If you're new to the Bot API, please see the manual (https://core.telegram.org/bots).
#
# You can control me by sending these commands:
#
# /newbot - create a new bot
# /mybots - edit your bots
#
# Edit Bots
# /setname - change a bot's name
# /setdescription - change bot description
# /setabouttext - change bot about info
# /setuserpic - change bot profile photo
# /setcommands - change the list of commands
# /deletebot - delete a bot
#
# Bot Settings
# /token - generate authorization token
# /revoke - revoke bot access token
# /setinline - toggle inline mode (https://core.telegram.org/bots/inline)
# /setinlinegeo - toggle inline location requests (https://core.telegram.org/bots/inline#location-based-results)
# /setinlinefeedback - change inline feedback (https://core.telegram.org/bots/inline#collecting-feedback) settings
# /setjoingroups - can your bot be added to groups?
# /setprivacy - toggle privacy mode (https://core.telegram.org/bots/features#privacy-mode) in groups
#
# Web Apps
# /myapps - edit your web apps (https://core.telegram.org/bots/webapps)
# /newapp - create a new web app (https://core.telegram.org/bots/webapps)
# /listapps - get a list of your web apps
# /editapp - edit a web app
# /deleteapp - delete an existing web app
#
# Games
# /mygames - edit your games (https://core.telegram.org/bots/games)
# /newgame - create a new game (https://core.telegram.org/bots/games)
# /listgames - get a list of your games
# /editgame - edit a game
# /deletegame - delete an existing game

# Имя (name) бота: Vlad28SF
# Имя пользователя (username) вашего бота: Vlad28SFBot
# Токен (token):

# filters — фильтры, определяющие, следует ли вызывать декорированную функцию для соответствующего сообщения или нет.
# У одного обработчика может быть несколько фильтров.
# Мы с вами разберём два основных фильтра:
#    - тип контента;
#    - команды.

# content_types  -  Список строк, по умолчанию ['text']
# Если тип контента, содержащегося в сообщении, совпадает с типом указанным в качестве аргумента. То есть обработчик
# по умолчанию реагирует на все текстовые сообщения.
# commands       -  Список строк
# Если сообщение начинается с команды, указанной в списке.

# import telebot
# import config
#
# TOKEN = "5957782602:AAEq8reL8N957GbRfGsqYgv-Kk6p5Ys1UC0"
#
# bot = telebot.TeleBot(TOKEN)
#
# # Обрабатываются все сообщения, содержащие команду '/start'.
# @bot.message_handler(commands=['start',])
# def handle_start(message):
#     bot.send_message(message.chat.id, f'{message.from_user.first_name}, привет')  # message.chat.username -
#
# # Обрабатываются все сообщения, содержащие команду '/help'.
# @bot.message_handler(commands=['help',])
# def handle_help(message):
#     pass
#
# # Обрабатывается все документы и аудиозаписи
# @bot.message_handler(content_types=['document', 'audio'])
# def handle_docs_audio(message):
#     pass
#
# @bot.message_handler(commands=['text',])
# def handle_text(message):
#     pass
#
# @bot.message_handler(content_types=['photo',])
# def handle_photo(message: telebot.types.Message):
#     bot.reply_to(message, 'Nice meme XDD')
#
# bot.polling(none_stop=True)


# Задание 5.3.2
# Напишите обработчик, который на сообщения с фотографией будет отвечать сообщением «Nice meme XDD».
# Бот должен отвечать не отдельным сообщением, а с привязкой к картинке
# @bot.message_handler(content_types=['photo',])
# def handle_photo(message: telebot.types.Message):
#     bot.reply_to(message, 'Nice meme XDD')


# Задание 5.4.4
# Напишите программу, которая будет с помощью парсера lxml доставать текст из тега tag2 следующего HTML:
# <html>
#  <head> <title> Some title </title> </head>
#  <body>
#   <tag1> some text
#      <tag2> MY TEXT </tag2>
#    </tag1>
#  </body>
# </html>


# import requests  # импортируем наш знакомый модуль
# import lxml.html
# from lxml import etree
#
# html = requests.get('https://ya.ru/').content  # получим html главной странички сайта с курсами
#
# tree = etree.parse('F:\Work\Vlad\Python\Задание5_4_4\Задание544.html', lxml.html.HTMLParser())
# # попытаемся спарсить наш файл с помощью html-парсера
#
# ul = tree.findall('/body/tag1')
#
# # создаём цикл, в котором мы будем выводить название каждого элемента из списка
# for tag2 in ul:
#     a = tag2.find('tag2')
#     print(a.text)


# Задание 5.4.5
# Используя полученные знания, допишите сделанный в начале юнита скрипт (где мы доставали заголовки новостей о Python с
# Python.org) так, чтобы он показывал ещё и дату добавления новости.
# Примечание: для получения атрибутов тега (т.е. его дополнительных параметров) используется метод .get(<имя атрибута>)
import requests  # импортируем наш знакомый модуль
# import lxml.html
# from lxml import etree
#
# # создадим объект ElementTree. Он возвращается функцией parse()
# tree = etree.parse('F:\Work\Vlad\Python\python_org\Welcome to Python.org.html', lxml.html.HTMLParser())
# # попытаемся спарсить наш файл с помощью html-парсера. Сам html - это то, что мы скачали и поместили в папку из браузера.
#
# ul = tree.findall('/body/div/div[3]/div/section/div[2]/div[1]/div/ul/li')
# # помещаем в аргумент метода findall скопированный xpath. Здесь мы получим все элементы списка новостей.
# # (Все заголовки и их даты)
#
# # создаём цикл, в котором мы будем выводить название каждого элемента из списка
# for li in ul:
#     a = li.find('a')  # в каждом элементе находим, где хранится заголовок новости. У нас это тег <a>. Т. е.
#                       # гиперссылка, на которую нужно нажать, чтобы перейти на страницу с новостью. (Гиперссылки
#                       # в html это всегда тег <a>)
#     news_time = li.find('time')
#     print(news_time.get('datetime'), a.text)


# Кеширование — это временное сохранение данных для дальнейшего доступа к ним.
# Установка Redis
# def my_redis():
#     red = redis.Redis(
#         host='localhost',
#         port=6379,
#         password=''
#     )

    # red.delete('dict1')  # удаляются ключи с помощью метода .delete()
    # print(red.get('dict1'))
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # dict1 = {'key1': 'value1', 'key2': 'value2'}  # создаём словарь для записи
    # red.set('dict1', json.dumps(dict1))  # с помощью функции dumps() из модуля json превратим наш словарь в строчку
    # converted_dict = json.loads(
    #     red.get('dict1'))  # с помощью знакомой нам функции превращаем данные, полученные из кеша обратно в словарь
    # print(type(converted_dict))  # убеждаемся, что мы получили действительно словарь
    # print(converted_dict)  # ну и выводим его содержание
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # red = redis.Redis(
    #     host='localhost',
    #     port=6379,
    #     password=''
    # )
    #
    # print(red.get('var1'))  # считываем из кеша данные
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # red = redis.Redis(
    #     host='localhost',
    #     # ваш хост, если вы поставили Редис к себе на локальную машину, то у вас это будет localhost. Если же вы находитесь на Windows, то воспользуйтесь полем host из вашей облачной БД, которую мы создавали в скринкасте.
    #     port=6379,
    #     # порт подключения. На локальной машине это должно быть 6379. Для пользователей облачного сервиса порт всегда разный, поэтому его надо копировать оттуда же, что и host.
    #     password=''
    #     # для локальной машины пароль не требуется (если вы устанавливали Редис к себе на компьютер и не пользовались облачным сервисом из скринкаста выше). Для пользователей облачного сервиса пароль находится в вашей облачной базе данных в поле password
    # )
    # red.set('var1', 'value1')  # записываем в кеш строку "value1"
    # print(red.get('var1'))  # считываем из кеша данные

# wsl --install запуск в windows powershell (не x68)

# Задание 5.5.4
# Напишите программу, которая будет записывать и кешировать номера телефонов ваших друзей.
# Программа должна уметь воспринимать несколько команд:
#  - записать номер;
#  - показать номер друга в консоли при вводе имени;
#  - удалить номер друга по имени.
# Кеширование надо производить с помощью Redis. Ввод и вывод информации должен быть реализован через консоль (с помощью функций input() и print())
# import redis
# import json
#
# red = redis.Redis(
#     host='localhost',
#     port=6379
# )
#
# class PhoneBook:
#     def __init__(self, name, phone):
#         self.name = name
#         self.phone = phone
#
#     def set_dict_row(self):
#         dict1[self.name] = self.phone
#         red.set('dict1', json.dumps(dict1))  # с помощью функции dumps() из модуля json превратим наш словарь в строчку
#         converted_dict = json.loads(red.get('dict1'))  # с помощью знакомой нам функции превращаем данные,
#                                                        # полученные из кеша обратно в словарь
#         print(type(converted_dict))  # убеждаемся, что мы получили действительно словарь
#         print(converted_dict)  # ну и выводим его содержание
#     def get_dict_row(self):
#         print(dict1[self.name])
#     def del_dict_row(self):
#         dict1.pop(self.name)
#         print(dict1[self.name])
#
# pb = PhoneBook('name', 'phone')
#
# print('Какое действие хотите выполнить?\n1. Дополнить словарь\n2. Получить номер по ФИО\n3. Удалить номер из словаря')
# action = int(input('Введите цифру действия: '))
#
# dict1 = {}  # создаём словарь для записи
#
# if action == 1:  # Дополнить словарь
#     pb.name = input('Введите ФИО друга: ')
#     pb.phone = input('Введите номер друга: ')
#     pb.set_dict_row()
#     print('dict1: ', dict1)
# elif action == 2:  # Получить номер по ФИО
#     pb.name = input('Введите ФИО друга: ')
#     pb.get_dict_row()
# else:  # Удалить номер из словаря
#     pb.name = input('Введите ФИО друга: ')
#     pb.del_dict_row()

# currency_dict = {'RUB': ['Российский рубль', 'рубль', 'рублей', 'Russian Ruble'],
#                  'USD': ['Доллары сша', 'доллар', 'долларов', 'баксы', 'баксов', 'us dollar', 'US Dollar'],
#                  'EUR': ['Евро', 'евро', 'евро', 'Euro'],
#                  'CNY': ['Китайский юань', 'юань', 'юаней', 'Chinese Yuan Renminbi'],
#                  }
#
# def find_dict_key(input_list):
#     base = input_list[0]
#     quote = input_list[1]
#     amount = round(float(input_list[-1]), 2)
#
#     base_code = ''
#     quote_code = ''
#
#     for dict_key, dict_values in currency_dict.items():
#         if dict_key == base:
#             print(dict_key, ' == ', base)
#             base_code = base
#         else:
#             for i in range(len(dict_values)):
#                 if dict_values[i] == base.lower():
#                     base_code = dict_key
#                     break
#
#         if dict_key == quote:
#             print(dict_key, ' == ', quote)
#         else:
#             for i in range(len(dict_values)):
#                 if dict_values[i] == quote.lower():
#                     quote_code = dict_key
#                     break
#
#     return [base_code, quote_code, amount]
# # input_list = ['евро', 'доллары', '10']
# input_list = ['EUR', 'RUB', '10']
# print(find_dict_key(input_list))

# DJANGO
# Чтобы создать статическую страницу нужно:
# Установить приложение (плагин) из встроенного пакета Django (добавить все необходимые конфиги в настройки и URL).
# Создать админа.
# Через админ-панель создать статические HTML-странички.
# При желании можно завернуть эти странички в определённый шаблон, но если его не указывать, то по умолчанию контент и
# название должны находится в шаблоне flatpages/default.html (убедитесь, что вы создали его, иначе на статическую
# страницу, которую вы создали, вы можете не попасть из-за ошибки).

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Изучение баз данных. PostgreSQL

# Для обработки информации важны:
# Скорость изменения данных: мы не должны ждать 5 минут, прежде чем обновятся остатки после проведения отгрузки товара.
# Надёжность: мы должны быть уверены, что изменения не потеряются.
# Многопользовательская модель работы: одновременно в нашей информационной системе могут работать тысячи пользователей,
# и мы должны быть уверены, что действия одного не блокируют работу остальных.

# Микросервисная архитектура — это архитектура информационной системы, предполагающая разделение сложной системы на
# отдельные небольшие самостоятельные сетевые службы с отдельными базами данных.

# 1	Термин: Сущность
#   Значение: Тип объекта реального мира, который требуется хранить в программе.
#   Пример: Товар, продавец.
#
# 2	Термин: Атрибут
#   Значение: Свойство сущности, характерное для всех или большинства экземпляров сущности.
#   Пример:
#        Для товара: цена, артикул, изготовитель.
#        Для продавца: адрес, веб-сайт.
#
# 3 Термин: Связь
#   Значение: Некоторая логическая связь между объектами реального мира.
#   Пример: У товара есть продавец. Продавцу принадлежат различные товары.
#
# 4	Термин: Ограничения
#   Значение: Ограничения, характерные для предметной области.
#   Пример: Количество цифр в номере телефона фиксировано,
#           цена не может быть отрицательной, название товара не может быть пустым,
#           все артикулы должны быть уникальными и так далее.

# !!! Создание модели данных — это представление той сферы деятельности, в которой мы работаем, в терминах сущностей,
#     атрибутов, связей и ограничений

# 1. Таблицы. Тут всё в соответствии со схемой: товары, продавцы, производители, категории, товары_категории (связь).
# 2. Индексы. Индексы ускоряют поиск. С помощью индексов линейная сложность поиска (в терминах О-нотации) превращается
#    в логарифмическую или даже константную. Нам нужно искать товары по категориям, продавцам, цене, производителям.
#    Для всех этих полей нам потребуется индекс. Для других таблиц индексы на данном этапе не требуются.
# 3. Последовательности. Для каждого идентификатора (ПК) будет автоматически создана инкрементальная последовательность.
#    Для нас этого достаточно.
# 4. Ограничения. Название товара, как и названия производителей, продавцов и категорий, не должны быть пустыми. Цена
#    должна быть больше нуля. Эти минимальные ограничения мы должны заложить в схему нашей БД.
# 5. Хранимых процедур, триггеров и представлений на данном этапе у нас не будет.

# СУБД — программное обеспечение, предоставляющее инструменты для управления базами данных и информацией, которая в них хранится
# СУБД предоставляют следующие основные возможности:
# - создание, изменение и удаление баз данных,
# - просмотр и изменение информации в БД,
# - вызов функций, хранимых процедур, триггеров,
# - обеспечение выполнения ограничений,
# - работа с последовательностями,
# - создание индексов,
# - создание представлений,
# - многое другое.

# СУБД используют двухэтапную операцию записи данных в память компьютера. Данные сначала пишутся в файл журнала
# опережающей записи (WAL), после чего они переносятся в основные файлы БД. Это сделано по нескольким причинам:
#  - Журнал позволяет вести учёт операций манипуляции данными и при необходимости отменить часть операций или
#    воспроизвести заново (например, при сбое системы).
#  - Журнал пишется в постоянной памяти последовательно, что быстрее, чем запись в файлы БД, где используется
#    случайный доступ (эта разница особенно заметна на HDD и не так существенна на SSD и NVME).
# Важнейшим для нас является тот факт, что реляционные СУБД обеспечивают выполнение требований ACID (атомарность,
# целостность, изолированность, надёжность):
#
# 1. Атомарность: данные не могут быть изменены частично (например, если мы создали запись в таблице, СУБД гарантирует,
#    что она будет создана полностью либо не создана вообще).
# 2. Согласованность: связанные данные изменяются вместе (например, мы не можем удалить таблицу, на которую ссылаются
#    вторичные ключи в других таблицах, сначала нужно будет удалить ссылки).
# 3. Изолированность: выполнение одной операции не может изменить суть выполнения других, параллельных операций.
# 4. Надёжность: СУБД гарантирует сохранение сделанных изменений даже в случае внезапного завершения работы или
#    обесточивания системы (см. WAL выше).
# Замечание. ACID — популярная тема на собеседованиях. Весьма вероятно, что вас попросят расшифровать эту аббревиатуру,
# объяснить смысл каждого термина и, возможно, привести какие-то примеры. Будьте готовы!
#
# Наиболее популярные современные реляционные СУБД:
# PostgreSQL, MySQL, SQLite (все свободные и бесплатные);
# Oracle DB, Microsoft SQL Server, IBM DB2 (все платные и весьма недешёвые!)

# Напоминаем основные концепции, рассмотренные в модуле. Если вы не можете сходу вспомнить суть чего-либо из
# перечисленного, прочитайте соответствующую статью или главу в выбранной книге и после этого переходите к
# выполнению заданий
#  1. Моделирование БД.
#  2. Сущность, атрибут, связь.
#  3. ER-диаграмма.
#  4. Реляционная (табличная) модель.
#  5. Нормализация данных. Нормальные формы.
#  6. Виды связей в БД.
#  7. Понятие БД.
#  8. Логическое представление данных в БД.
#  9. Таблицы, индексы, последовательности, ограничения.
# 10. ACID.
# 11. СУБД.
# 12. Журнал WAL.

# Задание 2.14.1. Самостоятельно потренируйтесь в моделировании БД и создании ER-диаграммы. Попробуйте смоделировать
# диаграмму для простого сервиса бесплатных объявлений. Модель должна включать в себя объявления, авторов, ключевые слова

# Задание 2.14.2. Установите СУБД PostgreSQL и инструмент администрирования PGAdmin. Подключитесь к серверу,
# создайте и удалите БД. Сервер и инструмент администрирования могут быть на разных компьютерах (виртуальных машинах,
# контейнерах). В таком случае сервер — обязательно на Linux

# !!! SQL (structured query language — язык структурированных запросов) — это язык программирования, позволяющий
#        выполнять любые операции с базами данных как таковыми и с любыми данными, которые хранятся в них.
#
# К важным особенностям языка SQL можно отнести следующие:
# - SQL — декларативный язык, то есть вы описываете конечный результат, а не алгоритм получения этого результата, как
#   принято в императивных языках (Python, Go, C, Java и так далее — императивные языки).
# - SQL появился в 70-х годах и относится к семейству pascal-подобных языков, а в наши дни больше распространены C-подобные языки.
# - Для SQL нет сред разработки (IDE), сравнимых по функционалу с современными средами вроде VS Code, PyCharm и так далее.

# Операторы (команды) языка SQL принято в соответствии со стандартом разделять на несколько групп.
# Нас будут интересовать только два основных подмножества:
# 1. DDL (data definition language — язык описания структуры данных)
# 2. DML (data manipulation language — язык манипулирования данными).
#
# Первая группа операторов предназначена для работы с базами данных и их объектами как таковыми,
# а вторая — для работы с самими данными

# DDL предназначен для создания, изменения и удаления самих БД и их объектов — таблиц, индексов, последовательностей,
#   представлений, ограничений и так далее.
# DML предназначен для работы с самими данными, которые хранятся в БД. DML позволяет читать данные из БД, изменять их,
#   удалять и создавать новые записи. DML всегда работает со строками в таблицах БД

# Пример запроса (программы) на языке SQL, создающей таблицу «Товары» в БД:
# -- Создание таблицы "Товары".
# CREATE TABLE products (
#     id BIGSERIAL PRIMARY KEY, -- первичный ключ
#     name TEXT NOT NULL, -- название товара
#     price INT CHECK(price > 0), -- цена (гарантируется, что цена > 0)
#     vendor_id BIGINT REFERENCES vendors(id), -- ссылка на продавца
#     manufacturer_id BIGINT REFERENCES manufacturers(id) -- ссылка на производителя
# );

# №	| Подмножество	| Оператор  |       Описание
# 1	| DDL           | CREATE    | Создаёт БД или объект БД (таблицы, индексы, триггеры и так далее).
# 2	| DDL           | ALTER     | Изменяет объект БД.
# 3	| DDL           | DROP      | Удаляет БД или объект БД.
# 4	| DML           | SELECT    | Чтение набора строк из одной или нескольких таблиц БД.
# 5	| DML           | INSERT    | Создание новой записи (строки) в таблице БД.
# 6	| DML           | UPDATE    | Обновление строки в таблице БД.
# 7	| DML           | DELETE    | Удаление строки из таблицы БД.

# Язык SQL обладает рядом особенностей синтаксиса, о которых стоит помнить. Самые важные из них:
# - SQL не чувствителен к регистру. То есть оператор SELECT можно записать как select, Select или даже sElECt. Однако принято все операторы и ключевые слова писать большими буквами, а все имена объектов и функций — маленькими. Придерживайтесь этого правила.
# - Каждый оператор должен заканчиваться точкой с запятой. Если вы её не поставите, будет ошибка, и запрос не выполнится.
# - Строки заключаются в одиночные кавычки.
# - Проверка равенства и установка значения осуществляются оператором =.
# - Запросы не чувствительны к переносу строк, пробелам и табуляции. Можно форматировать запросы любым удобным способом.
# - Однострочные комментарии начинаются с --.

# Оператор CREATE создаёт базы данных и любые их объекты
# CREATE TABLE vendors (
#     id SERIAL PRIMARY KEY, -- создание сиквенса
#     name TEXT NOT NULL
# );
# Основными объектами, которые чаще всего приходится создавать, являются:
# - таблицы,
# - атрибуты (столбцы) таблиц,
# - индексы,
# - последовательности
# Уточнение. Как правило, сами базы данных создаются интерактивно с помощью утилиты командной строки или графических
# инструментов вроде PGAdmin. Поэтому здесь и далее под объектами мы будем понимать любые объекты, кроме самих баз
# данных. Кроме того, запрос на создание БД в PostgreSQL нельзя совместить с операторами, изменяющими структуру этой БД.
# Так, этот запрос не сработает:
# CREATE DATABASE sales;
# CREATE TABLE orders (
#     id SERIAL,
#     amount BIGINT
# );
#
# Ошибка: ERROR:  CREATE DATABASE cannot run inside a transaction block

# Еще пример (корректный):
# -- Создание таблицы «Товары».
# CREATE TABLE products (
#     id BIGSERIAL PRIMARY KEY, -- первичный ключ
#     name TEXT NOT NULL, -- название товара
#     price INT CHECK(price > 0), -- цена (гарантируется, что цена > 0)
#     vendor_id BIGINT REFERENCES vendors(id), -- ссылка на продавца
#     manufacturer_id BIGINT REFERENCES manufacturers(id) -- ссылка на производителя
# );
#
# стоит обязательно изучить ограничения, доступные при описании столбцов таблиц:
# №	| Ограничение |           Описание
# 1	| NOT NULL    | Гарантирует, что в БД не попадут пустые значения.
# 2	| UNIQUE      | Гарантирует, что для данного столбца или группы столбцов все значения в таблице будут различаться.
# 3	| PRIMARY KEY | Делает атрибут или группу атрибутов первичным ключом (то есть NOT NULL UNIQUE).
# 4	| FOREIGN KEY | Обозначает внешний ключ: атрибут или группа атрибутов ссылаются на ключи в другой таблице и должны совпадать со значениями в ней.
# 5	| CHECK       | Произвольная проверка содержимого ячеек одного или нескольких столбцов.
# 6	| DEFAULT     | Предоставляет для столбца значение по умолчанию.

# -- Создание индекса для ускорения поиска по названию товара.
# CREATE INDEX product_name_idx ON products(name);

# INSERT INTO vendors (name) VALUES ('ООО Ромашка');
# SELECT * FROM vendors;
# EXPLAIN SELECT * FROM vendors;

# Пример 1. Переименование таблицы
# -- просмотр всех таблиц в схеме public
# SELECT * FROM pg_catalog.pg_tables WHERE schemaname = 'public';
# -- переименование таблицы posts в posts1
# ALTER TABLE posts RENAME TO posts1;
# -- проверка
# SELECT * FROM pg_catalog.pg_tables WHERE schemaname = 'public';
#
# CREATE TABLE ads(
# 	id SERIAL PRIMARY KEY,
# 	name TEXT NOT NULL,
# 	user_id INTEGER UNIQUE,
# 	adstext CHAR(1000)
# );
#
# -- INSERT INTO ads (name, user_id, adstxt) VALUES ('Ads2', 14, '01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567801234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567812342');
# -- SELECT * FROM ads;
#
# CREATE TABLE posts(
# 	id SERIAL PRIMARY KEY,
# 	autor TEXT NOT NULL UNIQUE,
# 	content TEXT NOT NULL
# );
#
# -- просмотр всех таблиц в схеме public
# SELECT * FROM pg_catalog.pg_tables WHERE schemaname = 'public';
# -- переименование таблицы posts в posts1
# ALTER TABLE posts1 RENAME TO posts;
# -- проверка
# SELECT * FROM pg_catalog.pg_tables WHERE schemaname = 'public';
#
# -- добавление столбца "дата публикации", хранящим время в формате Unix Time
# ALTER TABLE posts ADD COLUMN IF NOT EXISTS publication_date BIGINT NOT NULL;
# -- просмотр столбцов таблицы - проверка
# SELECT table_name, column_name, data_type
# FROM information_schema.columns
# WHERE table_name = 'posts';
# Обратите внимание на модификатор IF NOT EXISTS. Это ключевое слово означает создание объекта, только если он не
# существует. Рекомендуем использовать этот оператор или его вариант IF EXISTS при операциях создания, изменения и
# удаления объектов. Эти ключевые слова избавят вас от ошибок в ситуации, когда, к примеру, вы выполняете создание
# таблицы и не уверены, существует ли она.
#
# -- добавление ограничения уникальности для столбца с датой публикации
# ALTER TABLE posts ADD CONSTRAINT pub_date_unique UNIQUE(publication_date);

# Для ограничения в PostgreSQL нельзя использовать IF NOT EXISTS. Можно попытаться его удалить, используя IF EXISTS, после чего создать. Нелогично, но таков уж SQL!

# Для удаления используется оператор DROP. Этот оператор максимально прост:
# DROP [IF NOT EXISTS] тип_объекта имя_объекта;
# 1. Удаление БД:
#          DROP database db_name;
#
# 2. Удаление таблицы:
#          DROP TABLE IF EXISTS some_table;
# 3. Удаление столбца с датой публикации из таблицы
# ALTER TABLE posts DROP COLUMN publication_date;

# DROP TABLE IF EXISTS products_categories, products, categories, manufacturers, vendors;
# CREATE TABLE vendors (
#     id BIGSERIAL PRIMARY KEY,
#     name TEXT NOT NULL
# );
#
# CREATE TABLE manufacturers (
#     id BIGSERIAL PRIMARY KEY,
#     name TEXT NOT NULL,
#     website TEXT
# );
#
# CREATE TABLE categories (
#     id BIGSERIAL PRIMARY KEY,
#     name TEXT NOT NULL
# );
#
# -- Создание таблицы "Товары".
# CREATE TABLE products (
#     id BIGSERIAL PRIMARY KEY, -- первичный ключ
#     name TEXT NOT NULL, -- название товара
#     price INT CHECK(price > 0), -- цена (гарантируется, что цена > 0)
#     vendor_id BIGINT REFERENCES vendors(id), -- ссылка на продавца
#     manufacturer_id BIGINT REFERENCES manufacturers(id) -- ссылка на производителя
# );
# -- Создание индекса для ускорения поиска по названию товара.
# CREATE INDEX product_name_idx ON products(name);
#
# CREATE TABLE products_categories (
#     id BIGSERIAL PRIMARY KEY,
#     product_id BIGINT REFERENCES products(id),
#     category_id BIGINT REFERENCES categories(id)
# );
#
# -- Очистка всех таблиц перед наполнением тестовыми данными.
# TRUNCATE TABLE products_categories, categories, manufacturers, vendors, products;
#
# -- Наполнение таблиц тестовыми данными.
# INSERT INTO categories(name) VALUES
#     ('Музыкальные инструменты'), ('Профессиональное музыкальное оборудование'), ('Любительское музыкальное оборудование');
# INSERT INTO vendors(name) VALUES('Музторг'), ('4 четверти');
# INSERT INTO manufacturers(name, website) VALUES
#     ('Fender
#     ', 'fender.com'), ('Gibson','gibson.com'), ('Roland', 'roland.com');
# INSERT INTO products(name, price,  vendor_id, manufacturer_id) VALUES
#     ('Fender Stratocaster', 3500000, 2, 1),
#     ('Fender Telecaster', 3900000, 2, 1),
#     ('Fender Bullet', 1200000, 2, 1),
#     ('Gibson Les Paul', 5700000, 1, 2);
# INSERT INTO products_categories(product_id, category_id) VALUES
#     (1, 1), (1, 2), (3, 1), (3, 3);

# SELECT имя_таблицы1.имя_поля_1, ..., имя_таблицыn.имя_поля_n
# FROM имя_таблицы1, ..., имя_таблицы_n
# WHERE условие_объединения_таблиц AND условие_фильтрации
# ORDER BY имя_поля_сортировки;
#
# Пример 2. Получить все названия товаров, цену и названия продавцов и отсортировать по цене по убывающей
# SELECT products.name, products.price, vendors.name
# FROM products, vendors
# WHERE products.vendor_id = vendors.id
# ORDER BY price DESC
# Примечание. Часто бывает, что нужно получить только несколько строк из результирующего набора. В этом случае
# количество строк можно ограничить, добавив в конец LIMIT n. Например, LIMIT 10.
#
# Пример 3. Получить самый дорогой товар категории «Профессиональное оборудование»
# Получим самый дорогой товар категории «Профессиональное оборудование» с указанием названия товара, цены, названия продавца и названия производителя:
#
# SELECT
# 	products.name,
# 	products.price,
# 	vendors.name AS vendor,
# 	manufacturers.name AS manufacturer,
# 	categories.name AS category
# FROM products
# JOIN vendors ON products.vendor_id = vendors.id
# JOIN manufacturers ON products.manufacturer_id = manufacturers.id
# JOIN products_categories ON products_categories.product_id = products.id
# JOIN categories ON products_categories.category_id = categories.id
# WHERE products_categories.category_id = 2
# ORDER BY products.price DESC
# LIMIT 1

# Пример 1. Создание нескольких категорий товаров
# INSERT INTO
#     categories(name)
# VALUES
#     ('Музыкальные инструменты'),
#     ('Профессиональное музыкальное оборудование'),
#     ('Любительское музыкальное оборудование');
# Оператор INSERT достаточно прост, однако существуют две дополнительных возможности этого оператора, о которых следует знать.
# 1. Иногда требуется получить значения полей, созданных БД автоматически при вставке записей. Например, когда мы
#    создавали категории, то для атрибута id были автоматически сгенерированы и записаны в БД значения для каждой
#    новой записи. Конечно, можно прочитать все данные в таблице и найти новые записи по имени, но это неудобно. В
#    таких случаях используется ключевое слово RETURNING, которое позволяет вернуть значения атрибутов созданных записей.
# 2. Бывает, что вставляемые записи нарушают некоторое ограничение. Например, мы попытаемся добавить товар с
#    отрицательной ценой. В этом случае можно использовать ключевое слово ON CONFLICT для указания действия в случае
#    нарушения ограничения. Описание смотрите в документации к оператору по ссылке: https://postgrespro.ru/docs/postgresql/13/sql-insert

# UPDATE имя_таблицы
# SET атрибут_1 = значение_1, ... , атрибут_n = значение_n
# WHERE условие_поиска_записи_для_обновления;

# DELETE FROM имя_таблицы WHERE условие_отбора_записей_для_удаления;

# !!!!!!!   Для PostgreSQL этапы выполнения запроса выглядят так:
# 1. Подготовка. Синтаксический анализ запроса, оптимизация кода запроса, переписывание запроса в оптимизированной
#    форме, генерация итогового кода запроса.
# 2. Выполнение (интерпретация). Выполнение операторов с параметрами, переданными в запросе.
# 3. Результат. Формирование набора данных, полученных в результате выполнения запроса, и передача их клиентскому приложению

# Давайте посмотрим план несколько более сложного запроса к БД «Каталог товаров». Запрос:
#
# EXPLAIN SELECT products.*, categories.name
# FROM products
# JOIN products_categories ON products_categories.product_id = products.id
# JOIN categories ON products_categories.category_id = categories.id
# WHERE products_categories.category_id = 2
# План выполнения:
#
# Nested Loop  (cost=29.88..60.70 rows=8 width=92)
#   ->  Index Scan using categories_pkey on categories  (cost=0.15..8.17 rows=1 width=40)
#         Index Cond: (id = 2)
#   ->  Hash Join  (cost=29.73..52.45 rows=8 width=68)
#         Hash Cond: (products.id = products_categories.product_id)
#         ->  Seq Scan on products  (cost=0.00..19.20 rows=920 width=60)
#         ->  Hash  (cost=29.62..29.62 rows=8 width=16)
#               ->  Seq Scan on products_categories  (cost=0.00..29.62 rows=8 width=16)
#                     Filter: (category_id = 2)
# Как видите, здесь больше этапов и более сложный план. План предполагает использование индексов, объединение данных и фильтр результатов.
#
# Вы могли заметить, что план выполнения запроса содержит характеристику cost. Эта характеристика означает затраты на выполнение каждого из этапов плана выполнения. Именно уменьшение этого параметра и лежит в основе оптимизации и повышения производительности запросов. Однако стоит помнить, что:
#
# cost является оценкой, а не точным значением.
# Значения для cost приведены в условных единицах (а не в секундах или миллисекундах).

